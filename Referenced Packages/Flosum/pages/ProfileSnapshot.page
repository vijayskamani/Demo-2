<apex:page standardController="Flosum__Organisation__c" extensions="Flosum.ProfileSnapshotController" sidebar="false" doctype="html-5.0">
	<c:TrackPanel />
	<c:Wait />
	<c:DynamicLookupScript />
	<apex:includeScript value="{!URLFOR($Resource.Flosum__Utility, 'JS/angular.min.js')}"/>
	<apex:includeScript value="{!URLFOR($Resource.Flosum__Utility, 'JS/jsforce.min_1.7.0.js')}"/>
	<apex:includeScript value="{!URLFOR($Resource.Flosum__zipp,'res/ga.js')}"/>
	<apex:includeScript value="{!URLFOR($Resource.Flosum__zipp,'res/js/zip.js')}"/>
	<style>
		span#filterLabelId-_help {
            margin-right: 24px;
        }
        td.filterheaderclass {
            padding-left: 15px;
        }
        th.filterheaderclass {
            padding-left: 15px;
        }
        label.filterLabelLogiclabel {
            color: rgb(79, 74, 96);
            font-size: 11px;
        }
        th.filterheaderclass {
            color: rgb(79, 74, 96);
            font-size: 11px;
        }
        .daysLabel{
            color: rgb(79, 74, 96);
            font-size: 11px;
        }
        .disablePageLink{
        	pointer-events : none;
        }
	</style>
	<apex:form id="meta">
		<apex:pagemessages id="msg"/>
		<apex:actionfunction action="{!redirectToSnapshot}" immediate="true" reRender="msg" name="redirectToSnapshot" onComplete="hide();">
			<apex:param assignTo="{!snapshotId}" value="" name="snapshotId"/>
	  	</apex:actionfunction>
		<div ng-app="snapshotRetrieval" >
            <div ng-controller ="RetrieveChangesController" id="angularControllerId">
                <div class="ng-cloak">
                	<fieldset ng-disabled="disableUi">
						<apex:pageBlock html-ng-show="CommitStep == 2">
							<apex:pageBlockbuttons location="top">
                                <apex:commandbutton value="Save Snapshot" onClick="show();" reRender="none" oncomplete="fillPatchId('{!JSENCODE(selectedPatch)}');" html-ng-disabled="disablePushButton"/>
                            </apex:pageBlockbuttons>
							<apex:pageBlockSection columns="1">
								<apex:pageBlockSectionItem >
				                    <apex:outputLabel value="Org" />
				                    <apex:selectList size="1" value="{!selectedOrg}" html-ng-model="orgId">
				                        <apex:selectOptions value="{!orgOptions}"/>
				                        <apex:actionSupport event="onchange" onsubmit="show();" oncomplete="validateOrg(this.value);" reRender="none"/>
				                    </apex:selectList>
				                </apex:pageBlockSectionItem>
						        <apex:pageBlockSectionitem >
						        	<apex:outputLabel value="Patch"/>
						        	<apex:outputPanel >
							            <apex:inputHidden id="patchTargetId" value="{!selectedPatch}"/>
							            <apex:inputText size="25"  id="patchTargetName" onFocus="this.blur()" disabled="false"/>           
						  		    	<img src="/s.gif" 
							            onclick="dlm_openLookupPopup('{!$Component.patchTargetName}','{!$Component.patchTargetId}','{!$ObjectType.Patch__c.Name}',''); return false" 
							            class="{{disableUi == true ? 'lookupIcon disablePageLink' : 'lookupIcon'}}" 
							            onmouseout="this.className='lookupIcon';" 
							            alt="Patch Name Lookup (New Window)" 
							            onmouseover="this.className='lookupIconOn';"/>
						  		    </apex:outputPanel>
						        </apex:pageBlockSectionitem>
						        <apex:pageBlockSectionItem >
                                    <apex:outputLabel value="Snapshot Name"/>
                                    <apex:inputText html-ng-model="snapshotName"/>
                                </apex:pageBlockSectionItem>
                            </apex:pageBlockSection>
                            <apex:pageBlockSection html-ng-show="metadataTypeOptions.length > 0" columns="1">
                                <apex:PageBlockSectionItem >
                                    <apex:outputLabel value="Component Type"/>
                                    <select ng-model="selectedMetadataType" ng-change="showFirst();">
                                        <option value="{{''}}">All</option>
                                        <option ng-repeat="meta in metadataTypeOptions" value="{{meta}}">{{meta}}</option>
                                    </select>
                                </apex:PageBlockSectionItem>
                            </apex:pageBlockSection>
                            <apex:pageBlockSection html-ng-show="componentList.length > 0" columns="1">
                                <div>
                                    <apex:pageBlockSection columns="1">
                                        <table ng-show="componentList.length > 0" class="list">
                                            <thead>
                                                <tr class="headerRow">
                                                    <th>No.</th>
                                                    <th><input type="checkbox" ng-click="checkItemAll(isAllChecked,(componentList | filter:filterForSearch | orderBy: orderByColumn :isReverse | limitTo: viewLimit),metaOffSet);" class="psli" ng-model="isAllChecked" >&nbsp;</input></th>
                                                    <th ng-repeat = "(key, value) in fieldSet">
                                                        <a ng-click="refreshOrderBy(key)">{{ orderByColumn == key ? isReverse ? value+' ▼' : value+' ▲' : value }}</a>
                                                    </th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr ng-repeat = "meta in componentList | filter:filterForSearch | orderBy: orderByColumn :isReverse | limitTo: viewLimit" ng-if="$index >= metaOffSet" class="dataRow"
                                                onmouseover="if (window.hiOn){hiOn(this);} " onmouseout="if (window.hiOff){hiOff(this);} ">
                                                    <td>{{ $index+1 }}</td>
                                                    <td><input type="checkbox" class="sli" ng-click="checkUnCheck((componentList | filter:filterForSearch | orderBy: orderByColumn :isReverse | limitTo: viewLimit),metaOffSet);" ng-model="meta.checked"/></td>
                                                    <td ng-repeat = "(key, value) in fieldSet">
                                                        {{ meta[key == 'lastModifiedDate'? 'changedOn' : key == 'createdDate' ? 'createdOn' : key] }}
                                                    </td>
                                                 </tr>
                                            </tbody>
                                        </table>
                                    </apex:pageBlockSection>
                                    <apex:outputPanel html-ng-show="componentList.length > 0" styleClass="pagination" layout="block" style="text-align: center;">
                                        <apex:commandbutton html-ng-click="showFirst();" onClick="return false;" value="First" reRender="none" html-ng-disabled="isPrevious();"/>
                                        <apex:commandbutton html-ng-click="listPrevious();" onClick="return false;" value="Previous" reRender="none" html-ng-disabled="isPrevious();"/>
                                        Total {{(componentList|filter:filterForSearch).length}} components, Page {{currentPageNo((componentList|filter:filterForSearch).length)}} of {{totalPageCount((componentList|filter:filterForSearch).length)}}
                                        <apex:commandbutton html-ng-click="listNext((componentList|filter:filterForSearch).length);" onClick="return false;" value="Next" reRender="none" html-ng-disabled="isNext((componentList | filter:filterForSearch).length);"/>
                                        <apex:commandbutton html-ng-click="showLast((componentList|filter:filterForSearch).length);" onClick="return false;" value="Last" reRender="none" html-ng-disabled="isNext((componentList | filter:filterForSearch).length);"/>
                                    </apex:outputPanel>
                                </div>
                            </apex:pageBlockSection>
                        </apex:pageBlock>
                	</fieldset>
                </div>
            </div>
        </div>
	</apex:form>
	<script>
        Visualforce.remoting.timeout = 120000;
        zip.workerScriptsPath = "{!URLFOR($Resource.zipp,'res/js/workers')}/";
        var zipFileEntry, zipWriter, writer, creationMethod, URL = window.webkitURL || window.mozURL || window.URL;
        
        function setFilterFromLookup(filterIndex,fieldType,selectedItems)
        {
            angular.element(document.getElementById('angularControllerId')).scope().setFilterRow(filterIndex,fieldType,selectedItems);
        }
        
        function validateOrg(organizationId)
        {
        	angular.element(document.getElementById('angularControllerId')).scope().applyBeforeValidate(organizationId);
        }
        
        function fillPatchId(patchId)
        {
        	//angular.element(document.getElementById('angularControllerId')).scope().disableUi = true;
        	angular.element(document.getElementById('angularControllerId')).scope().retrievePatchPermissions(patchId);
        	//hide();
        }
        
        var myApp = angular.module("snapshotRetrieval", []);
        myApp.controller("RetrieveChangesController", function($scope) {
			/****************************Default Properties*******************************/
			//$scope.selectedCategory = 'all';
			$scope.packagePermissions = {
				CustomObject 		: [],
        		ApexClass 			: [],
        		ApexPage 			: [],
        		Layout 				: [],
        		CustomTab 			: [],
        		CustomApplication 	: [],
        		ExternalDataSource 	: [],
        		CustomPermission 	: [],
        		CustomField 		: [],
        		RecordType 			: []
        	};
        	$scope.selectedPatch = '';
			$scope.apiVersion = {!localApiVersion};
			$scope.orgId;
			$scope.orgDetailId;
			$scope.metadataTypeAvailableStr = '{!JSENCODE(metadataTypeStr)}';
			$scope.authDetails;
			$scope.metaTypeLi = [];
			$scope.selectedTypes = []
            $scope.disableUi = false;
			$scope.visibleStateConditionStr = '';
			//$scope.availableForCommitLi = [];
			$scope.selectedForSnapshotLi = [];
			$scope.createMetadataIndex = 0;
			$scope.CommitStep = 2;
			$scope.snapshotId;
			$scope.logId;
			$scope.snapshotName;
			$scope.filterDays = 0;
			$scope.filterTime;
			$scope.IsRetrieveStandard = false;
			$scope.disablePushButton = true;
			$scope.IsRetrievePackagePermissions = true;
			$scope.queryIndex = 0;
			$scope.remainingTypesMap = {};
			$scope.objectNamesLi = [];
			$scope.filteredMetaDataItems = {};
			$scope.selectedMap = {};
			$scope.requestDetailLi = [];
			$scope.AsyncIdMap = {};
			$scope.AsyncIdLi = [];
			$scope.RemainingLi = [];
			$scope.AsyncIdIndex = 0;
			$scope.conn1;
            $scope.snapshotDetailLog = '';
			/*****************************************************************************/
            /****************************Pagination Properties****************************/
			$scope.selectedMetadataType = '';
			$scope.metadataTypeOptions = [];
			$scope.uniquemetaTypeOptions = {};
			$scope.isAllChecked = false;
            $scope.componentList = [];
            $scope.orderByColumn = 'lastModifiedDate';
            $scope.isReverse = true;
            $scope.metaOffSet = 0;
            //$scope.totalRecords = 0;
            $scope.staticLimit = 50;
            $scope.viewLimit = $scope.staticLimit;
            var tempObj = {};
            //tempObj['id'] = 'Id';
            tempObj['fullName'] = 'Component Name';
            tempObj['type'] = 'Component Type';
            tempObj['lastModifiedByName'] = 'Changed By';
            tempObj['lastModifiedDate'] = 'Changed On';
            tempObj['createdByName'] = 'Created By';
            tempObj['createdDate'] = 'Created On';
            //tempObj['changedOn'] = 'Changed On';
            $scope.fieldSet = tempObj;

            /**************************************************************************/
            /****************************Static Properties*****************************/
            $scope.manageableStateToRetrieve = {};
	        $scope.manageableStateToRetrieve['released'] = 'released';
	        $scope.manageableStateToRetrieve['unmanaged'] = 'unmanaged';
	        $scope.manageableStateToRetrieve['beta'] = 'beta';
	        $scope.manageableStateToRetrieve[undefined] = 'undefined';
            if('{!JSENCODE(metadataTypeStr)}' != '')
            {
                var metaStrLi = $scope.metadataTypeAvailableStr.split(',');
                for(var listIndex = 0; listIndex < metaStrLi.length; listIndex++)
                {
                    $scope.metaTypeLi.push(metaStrLi[listIndex]);
                }
            }
            
            $scope.applyBeforeValidate = function (organizationId) {
            	$scope.$apply(function() {
            		$scope.disablePushButton = true;
        			$scope.showMessage("",'INFO');
        			$scope.orgId = organizationId;
        			$scope.componentList = [];
        			$scope.metadataTypeOptions = [];
        			if($scope.orgId != undefined && $scope.orgId != '')
        			{
        				$scope.validateWithOrg();
        			}
        			else
        				hide();
            	});
            }
            
            /****************************Main Methods****************************/
            $scope.validateWithOrg = function(organizationId) {
            	Visualforce.remoting.Manager.invokeAction(
					'{!$RemoteAction.ProfileSnapshotController.authenticateWithOrg}',
					$scope.orgId,
					function(r,e){
                    	$scope.$apply(function() {
  							if(e.status && r) 
  							{
  								if(r.isSuccess && r.details != undefined)
  								{
  									$scope.authDetails = r;
  									$scope.orgDetailId = r.details.Id;
									$scope.filterOrgComponents();
  								}
  								else
  								{
  									$scope.showMessage(r.errorMessage,'ERROR');
  								}
  							}
  							else
  							{
  								$scope.showMessage(e.message,'ERROR');
  							}
  						hide();
                	});
				});
            }
            //Retrive information about patch permission components
            $scope.retrievePatchPermissions = function(patchId) {
            	$scope.$apply(function() {
	            	$scope.selectedPatch = patchId;
	            	$scope.disableUi = true;
	           		console.log('$scope.selectedPatch--'+$scope.selectedPatch);
	           		hide();
           		});
            	Visualforce.remoting.Manager.invokeAction(
					'{!$RemoteAction.ProfileSnapshotController.listPatchPermissions}',
					$scope.selectedPatch,
					function(r,e){
                    	$scope.$apply(function() {
  							if(e.status && r) 
  							{
  							    	angular.forEach($scope.packagePermissions, function(value, key) {
				                    	$scope.packagePermissions[key] = [];
				                    	
				    				});
				    				angular.forEach(r, function(value, key) {
				                    	if(value != undefined && value.metadataType != undefined && value.componentNames != undefined)
				                    		$scope.packagePermissions[value.metadataType] = value.componentNames;
				    				});
				    				console.log($scope.packagePermissions);
				                $scope.createSnapshot();
  							}
  							else
  							{
  								$scope.showMessage(e.message,'ERROR');
  							}
                	});
				});
            };
            //Create snapshot of selected metadata items.
            $scope.createSnapshot = function() {
                $scope.showMessage("",'INFO');
            	$scope.disableUi = true;
            	$scope.createMetadataIndex = 0;
            	$scope.selectedForSnapshotLi = [];
            	
		        $scope.selectedMap = {};
                
            	angular.forEach($scope.componentList, function(value, key) {
            		if(value.checked)
            		{
            			if(value.type == 'Profile' || value.type == 'PermissionSet')
            			{
                            //Retrieval of Profile and PermissionSet will be by JS.
            				var selectedLi = [];
	            			if($scope.selectedMap[value.type] != undefined)
	            			{
	            				selectedLi = $scope.selectedMap[value.type];
	            			}
	            			selectedLi.push(value);
	            			$scope.selectedMap[value.type] = selectedLi;
            			}
            		}
            	});
            	if(!angular.equals({}, $scope.selectedMap))
            	{
            		if($scope.snapshotName != undefined && $scope.snapshotName.trim() != '' )
            		{
            			$scope.snapshotName = $scope.snapshotName.trim();
		            	Visualforce.remoting.Manager.invokeAction(
							'{!$RemoteAction.ProfileSnapshotController.createSnapshot}',
							$scope.snapshotName,
							$scope.orgId,
							$scope.filterDays,
							function(r,e){
                                $scope.$apply(function() {
    					        	if(e.status && r) 
    							    {
    							    	if(r.isSuccess && r.snapId != undefined && r.logId != undefined)
    							    	{
    							    		$scope.snapshotId = r.snapId;
    							    		$scope.logId = r.logId;
                                            $scope.showMessage("Creating snapshot...",'INFO');
    							    		$scope.createMetaDataItemOneByOne();
    							    	}
    							    	else
                                        {
    							    		$scope.showMessage(r.errorMessage,'ERROR');
                                        }
    							    }
    							    else
    							    {
    							    	$scope.showMessage(e.message,'ERROR');
    							    }
                                });
						});
					}
					else
						$scope.showMessage('Please Enter Snapshot Name.','ERROR');
				}
				else
					$scope.showMessage('Please select a component.','ERROR');
            };
            //To create metadata items in chunks
            $scope.createMetaDataItemOneByOne = function(){
            	if($scope.createMetadataIndex < $scope.selectedForSnapshotLi.length)
            	{
                    $scope.showMessage("Creating snapshot...",'INFO');
            		var metaItemDetailLi = [];
            		var commitIndex = 0;
            		for(;(commitIndex < 600 && $scope.createMetadataIndex < $scope.selectedForSnapshotLi.length);)
            		{
            			var tempMeta = $scope.selectedForSnapshotLi[$scope.createMetadataIndex];
            			tempMeta.snapId = $scope.snapshotId;
            			metaItemDetailLi.push(tempMeta);
            			commitIndex++;
            			$scope.createMetadataIndex++;
            		}
            		Visualforce.remoting.Manager.invokeAction(
						'{!$RemoteAction.ProfileSnapshotController.createMetadataItems}',
						JSON.stringify(metaItemDetailLi),
						function(r,e){
                            $scope.$apply(function() {
    				        	if(e.status && r) 
    						    {
    						    	if(r.isSuccess)
    						    	{
    						    		$scope.createMetaDataItemOneByOne();
    						    	}
    						    	else
    						    		$scope.showMessage(r.errorMessage,'ERROR');
    						    }
    						    else
    						    {
    						    	$scope.showMessage(e.message,'ERROR');
    						    }
    						});
					});
            	}
            	else
            	{
            		if(angular.equals({}, $scope.selectedMap))
                    {
                        //Snapshot done.
                        console.log('Retrieval completed');
            			redirectToSnapshot($scope.snapshotId);
                    }
            		else
            			$scope.createRequestForProfileAndPermissionSet();
            	}
            };

			$scope.finishFilterMetaItems = function() {
            	$scope.showMessage('','INFO');
	            $scope.$apply(function() {
	            	$scope.disableUi = false;
	            	$scope.componentList = [];
	            	$scope.selectedMetadataType = '';
					$scope.metadataTypeOptions = [];
	
					$scope.isAllChecked = false;
		            $scope.orderByColumn = 'lastModifiedDate';
		            $scope.isReverse = true;
		            $scope.metaOffSet = 0;
		            
	            	var sortedtMetaTypeList = [];
	            	angular.forEach($scope.filteredMetaDataItems, function(value, key) {
	            		sortedtMetaTypeList.push(key);
	           			angular.forEach($scope.filteredMetaDataItems[key], function(metaItem) {
	           				$scope.componentList.push(metaItem);
	            		});
	            	});
	            	sortedtMetaTypeList.sort();
	            	$scope.metadataTypeOptions = sortedtMetaTypeList;
	            	if($scope.componentList.length > 0)
	            	{
	            		$scope.disableRetrieveChangesButton = true;
	            		$scope.disablePushButton = false;
	            		$scope.CommitStep = 2;
	            	}
	            	else
	            	{
	            		$scope.showMessage('No changes found.','INFO');
	            	}
            	});
            };
			
            $scope.filterOrgComponents = function() {
            	$scope.filteredMetaDataItems = {};
            	$scope.selectedTypes = [];
            	console.log($scope.filterDays);
            	console.log('$scope.orgId--------'+$scope.orgId);
            	console.log('$scope.orgDetailId--'+$scope.orgDetailId);

           		$scope.disablePushButton = true;
           		$scope.disableUi = true;
           		$scope.selectedTypes.push('Profile');
           		//$scope.selectedTypes.push('PermissionSet');
				if($scope.selectedTypes != undefined && $scope.selectedTypes.length > 0)
				{
					$scope.listComponents();
				}
				else
				{
					$scope.showMessage('Please select a component type.','ERROR');
				}
            };
            
            $scope.createRequestForProfileAndPermissionSet = function() {
            	if($scope.selectedMap['Profile'] != undefined || $scope.selectedMap['PermissionSet'] != undefined)
            	{
            		$scope.conn1 = $scope.createConnection($scope.authDetails.details.AccessToken,$scope.authDetails.details.InstanceURL);
            		$scope.requestDetailLi = [];
            		if($scope.selectedMap['Profile'] != undefined)
            		{
	            		var requestDetail = {};
	            		requestDetail.MetaType = 'Profile';
	            		requestDetail.Items = [];
		                requestDetail.ItemNames = [];
	            		angular.forEach($scope.selectedMap['Profile'], function(value, key) {
		                    if(key % 18 == 0 && requestDetail.Items.length > 0)
		                    {
		                    	$scope.requestDetailLi.push(requestDetail);
		                    	requestDetail = {};
			            		requestDetail.MetaType = 'Profile';
			            		requestDetail.Items = [];
				                requestDetail.ItemNames = [];
		                    }
		                    requestDetail.Items.push(value);
		                    requestDetail.ItemNames.push(value.fullName);
	                   	});
	                   	if(requestDetail.Items.length > 0)
	                   	{
	                   		$scope.requestDetailLi.push(requestDetail);
	                   	}
                   	}
                   	if($scope.selectedMap['PermissionSet'] != undefined)
            		{
	            		var requestDetail = {};
	            		requestDetail.MetaType = 'PermissionSet';
	            		requestDetail.Items = [];
		                requestDetail.ItemNames = [];
	            		angular.forEach($scope.selectedMap['PermissionSet'], function(value, key) {
		                    if(key % 15 == 0 && requestDetail.Items.length > 0)
		                    {
		                    	$scope.requestDetailLi.push(requestDetail);
		                    	requestDetail = {};
			            		requestDetail.MetaType = 'PermissionSet';
			            		requestDetail.Items = [];
				                requestDetail.ItemNames = [];
		                    }
		                    requestDetail.Items.push(value);
		                    requestDetail.ItemNames.push(value.fullName);
	                   	});
	                   	if(requestDetail.Items.length > 0)
	                   	{
	                   		$scope.requestDetailLi.push(requestDetail);
	                   	}
                   	}
                   	console.log($scope.requestDetailLi);
                   	console.log('$scope.requestDetailLi.length--'+$scope.requestDetailLi.length);
                   	if($scope.requestDetailLi.length > 0)
                   	{
                   		$scope.processRequestForRetrieval();
                   	}
            	}
            };
            
            $scope.processRequestForRetrieval = function() {
            	if($scope.requestDetailLi.length > 0)
	            {
	            	$scope.AsyncIdMap = {};
	            	$scope.AsyncIdLi = [];
	            	$scope.AsyncIdIndex = 0;
	            	$scope.RemainingLi = [];
	            	$scope.BreakeAsyncLi = [];
	            	/*
	            	$scope.AsyncIdMap = {};
					$scope.AsyncIdLi = [];
					$scope.RemainingLi = [];
					$scope.AsyncIdIndex = 0;
					
					$scope.BreakeAsyncLi = [];
					*/
					var createRequestIndex = 0;
					var createRequestOneByOne = function() {
						if(createRequestIndex < $scope.requestDetailLi.length)
						{
							var requestDetail = $scope.requestDetailLi[createRequestIndex];
							var req = $scope.getRetrieveRequest();
							var oneType = {};
							oneType.name = requestDetail.MetaType;
							oneType.members = requestDetail.ItemNames;
							req.unpackaged.types.push(oneType);
							angular.forEach($scope.packagePermissions, function(value, key) {
								if(value != undefined && value.length > 0)
								{
									var oneType2 = {};
									oneType2.name = key;
									oneType2.members = value;
									req.unpackaged.types.push(oneType2);
								}
							});
                            $scope.showMessage("Creating requests for retrieval.",'INFO');
                            console.log('creating retrieval request '+(createRequestIndex+1)+'/'+$scope.requestDetailLi.length);
                            console.log(req);
		            		$scope.conn1.metadata.retrieve(req,function(err, result){
								if(err)
								{
									console.log('Error while creating retrieval request.');
									/*if(err != null && err != undefined && err.errorCode != undefined)
						           	{
						           		snapshotDetailLog+= getCurrentTime()+": "+'Error while creating retrieval request of '+requestDetail.MetaType+' '+err.errorCode+' ('+err.message+').\n';
						           	}
						           	else
						           	{
						           		
						           		snapshotDetailLog+= getCurrentTime()+": "+'Error while creating retrieval request of '+requestDetail.MetaType+' (No response received from the server).\n';
						           	}*/
								}
								else
								{
									if(result != undefined && result.id != undefined)
									{
										$scope.AsyncIdMap[result.id] = requestDetail;
									}
								}
								createRequestIndex++;
								createRequestOneByOne();
							});
						}
						else
						{
                            angular.forEach($scope.AsyncIdMap, function(value, key) {
                                $scope.AsyncIdLi.push(key);
                            });
							console.log('Request created.');
							console.log('$scope.AsyncIdLi.length--'+$scope.AsyncIdLi.length);
                            console.log($scope.AsyncIdLi);
                            console.log($scope.AsyncIdMap);
							
                            var remainingTime = 20;
                            var timeCounter = function() {
                                if(remainingTime > 0)
                                {
                                    $scope.showMessage("Retrieval status check is scheduled after "+remainingTime+" seconds.",'INFO');
                                    remainingTime--;
                                    setTimeout(timeCounter, 1000);
                                }
                                else
                                {
                                    setTimeout($scope.checStatusOfRetrievalRequest,0);
                                }
                            }
                            timeCounter();					
						}
					}
					createRequestOneByOne();
            	}
            };
            
            $scope.checStatusOfRetrievalRequest = function() {
            	if($scope.AsyncIdIndex < $scope.AsyncIdLi.length)
            	{
            		console.log('Checking retrieval status--'+($scope.AsyncIdIndex+1)+'/'+$scope.AsyncIdLi.length);
					var currentAsyncId = $scope.AsyncIdLi[$scope.AsyncIdIndex];
					var requestDetail = $scope.AsyncIdMap[currentAsyncId];
					var currentMetaType = requestDetail.MetaType;
                    $scope.showMessage('Retrieving '+currentMetaType+'.','INFO');
					$scope.conn1.metadata.checkRetrieveStatus(currentAsyncId,function(err,result){
	        			if(err) 
			            {
			            	console.log('Error while checking retrieval request.');
							console.log(err);
							$scope.BreakeAsyncLi.push(currentAsyncId);
							$scope.continueCheckNextRequest();
			            }
			            else
			            {
			            	if(result != undefined && result.id != undefined)
							{
								if(result.done == 'true')
								{
									if(result.success == 'true' && result.zipFile != undefined)
									{
										$scope.readAndCreateMetadataItem(result.zipFile,requestDetail);
									}
									else
									{
										$scope.BreakeAsyncLi.push(result.id);
										$scope.continueCheckNextRequest();
									}
								}
								else
								{
                                    console.log('Request is in progress on server.');
									$scope.RemainingLi.push(result.id);
									$scope.continueCheckNextRequest();
								}
							}
			            }
			    	});
            	}
            	else
            	{
            		if($scope.RemainingLi.length > 0)
            		{
            			$scope.AsyncIdLi = [];
            			angular.forEach($scope.RemainingLi, function(value, key) {
            				$scope.AsyncIdLi.push(value);
            			});
            			$scope.AsyncIdIndex = 0;
            			$scope.RemainingLi = [];

                        var remainingTime = 20;
                        var timeCounter = function(){
                            if(remainingTime > 0)
                            {
                                $scope.showMessage("Retrieval status check is scheduled after "+remainingTime+" seconds.",'INFO');
                                remainingTime--;
                                setTimeout(timeCounter, 1000);
                            }
                            else
                            {
                                setTimeout($scope.checStatusOfRetrievalRequest,0);
                            }
                        }
                        timeCounter();
            		}
            		else if($scope.BreakeAsyncLi.length > 0)
	            	{
	            		$scope.requestDetailLi = [];
            			angular.forEach($scope.BreakeAsyncLi, function(currentAsyncId, key) {
							var requestDetail = $scope.AsyncIdMap[currentAsyncId];
							var currentMetaType = requestDetail.MetaType;
							if(requestDetail.Items != undefined && requestDetail.Items.length > 1)
							{
								var dynamicLimit;
								if(requestDetail.Items.length > 5)
									dynamicLimit = Math.floor(requestDetail.Items.length *.50);
								else
									dynamicLimit = 1;	
								var localItemNames = [];
								var localItems = [];
								for(var loopIndex=0; loopIndex < requestDetail.Items.length; loopIndex++)
								{
									var localIm = requestDetail.Items[loopIndex];
									if(loopIndex % dynamicLimit == 0 && localItemNames.length > 0)
									{
										var breakedAsyncDetail = {};
										breakedAsyncDetail.IsFirst = false;
										breakedAsyncDetail.MetaType = currentMetaType;
										breakedAsyncDetail.ItemNames = localItemNames;
										breakedAsyncDetail.Items = localItems;
										console.log('Previous--'+requestDetail.ItemNames.length+'---Should--'+dynamicLimit+'--Exact--'+breakedAsyncDetail.ItemNames.length);
										$scope.requestDetailLi.push(breakedAsyncDetail);
										localItemNames = [];
										localItems = [];
									}
									localItems.push(localIm);
									localItemNames.push(localIm.fullName);
								}
								if(localItemNames.length > 0)
								{
									var breakedAsyncDetail = {};
									breakedAsyncDetail.IsFirst = false;
									breakedAsyncDetail.MetaType = currentMetaType;
									breakedAsyncDetail.ItemNames = localItemNames;
									breakedAsyncDetail.Items = localItems;
									console.log('Previous--'+requestDetail.ItemNames.length+'---Should--'+dynamicLimit+'--Exact--'+breakedAsyncDetail.ItemNames.length);
									$scope.requestDetailLi.push(breakedAsyncDetail);
								}
							}
							else
							{
								for(var loopIndex=0; loopIndex < requestDetail.Items.length; loopIndex++)
								{
									var localIm = requestDetail.Items[loopIndex];
									//snapshotDetailLog+= getCurrentTime()+": Unable to retrieve "+currentMetaType+" "+localIm.fullName+".\n";
									console.log("Unable to retrieve "+currentMetaType+" "+localIm.fullName+".");
								}
							}
						});
						if($scope.requestDetailLi.length > 0)
						{
							$scope.processRequestForRetrieval();
						}
						else
						{
                            console.log('Retrieval completed');
							redirectToSnapshot($scope.snapshotId);
						}
            		}
            		else
            		{
                        console.log('Retrieval completed');
            			redirectToSnapshot($scope.snapshotId);
            		}
            	}
            };
            
            $scope.continueCheckNextRequest = function() {
            	$scope.AsyncIdIndex++;
				setTimeout($scope.checStatusOfRetrievalRequest, 0);
            };
            
            $scope.readAndCreateMetadataItem = function(zipStr,requestDetail) {
            	if(zipStr != undefined)
            	{
            		var fileZipWriter;
            		var currentMetaType = requestDetail.MetaType;
            		//var permissionFileMap = {};
            		var readZipFiles = function() {
            			zip.createReader(new zip.Data64URIReader(zipStr), function(reader) {
               				var EntryIndex = 0;
               				reader.getEntries(function(entries) {
								if(entries.length)
								{
									var readSingleFile = function(){
									    if (EntryIndex < entries.length) 
									    {
									    	var singleEntry = entries[EntryIndex];
									    	var fileName = singleEntry.filename;
									    	if(fileName != undefined && (fileName.indexOf("profiles/") == 0 || fileName.indexOf("permissionsets/") == 0 )) 
							            	{
										    	entries[EntryIndex].getData(new zip.BlobWriter(), function(newXml) {
										    		fileZipWriter.add(fileName, new zip.BlobReader(newXml), function() {
										    			EntryIndex++;
														readSingleFile();
                                    				});
										    	});
										    }
										    else
										    {
										    	EntryIndex++;
												readSingleFile();
										    }
									    }
									    else
									    {
									    	fileZipWriter.close(function(base64Data) {
                                                base64Data = base64Data.slice(base64Data.indexOf(';base64,') + 8);
                                                console.log(base64Data.length);
                                                console.log('Zip Created successfully.');
                                                var selfConn = new jsforce.Connection({ accessToken: '{!$API.Session_Id}' });
                                                var att = {};
									            att.Name = currentMetaType;
									            att.ContentType = 'application/zip';
									            att.Description = currentMetaType;
										 		att.ParentId = $scope.snapshotId;  
												att.Body = base64Data;
                                                selfConn.sobject("Attachment").create(att, function(err, rets) {
													if(err || !rets.success) 
													{ 
														//showMessage(err.errorCode);
														//return console.error(err); 
														$scope.showMessage(err.errorCode,'ERROR');
													}
													else
													{
														console.log(rets);
														if(rets != undefined && rets.id != undefined)
														{
															var metaItemDetailLi = [];
															angular.forEach(requestDetail.Items, function(tempMeta, key) {
											            		tempMeta.snapId = $scope.snapshotId;
										            			tempMeta.attId = rets.id;
										            			metaItemDetailLi.push(tempMeta);
											            	});
										            		Visualforce.remoting.Manager.invokeAction(
																'{!$RemoteAction.ProfileSnapshotController.createMetadataItems}',
																JSON.stringify(metaItemDetailLi),
																function(r,e){
														        	if(e.status && r) 
																    {
																    	if(r.isSuccess)
																    	{
																    		$scope.continueCheckNextRequest();
																    	}
																    	else
																    		$scope.showMessage(r.errorMessage,'ERROR');
																    }
																    else
																    {
																    	$scope.showMessage(e.message,'ERROR');
																    }
																}
															);
														}
													}
												});
           									});
									    }
									}
									readSingleFile();
								}
								else
								{
									$scope.continueCheckNextRequest();
								}
							});
               			}, function(error) {
							// onerror callback
							console.log('Error in reading file from attachments.');
							console.log(error);	
							if(error.message != undefined)
								$scope.showMessage(error.message,'ERROR');
							else
								$scope.showMessage('Unknown error.','ERROR');								
						});
					}
					
					zip.createWriter(new zip.Data64URIWriter(), function(writer2) {
						fileZipWriter = writer2;
						readZipFiles();
					}, function(error) {
						// onerror callback
                        console.log('Error while creating single zip.');
                        console.log(error);
                        if(error.message != undefined)
							$scope.showMessage(error.message,'ERROR');
						else
							$scope.showMessage('Unknown error.','ERROR');
					});
				}
            }
            
            $scope.listComponents = function() {
            	$scope.queryIndex = 0;
            	$scope.remainingTypesMap = {};
            	$scope.objectNamesLi = [];
            	$scope.listSimpleMetadataTypeOneByOne();
            };
            
            $scope.listSimpleMetadataTypeOneByOne = function() {
            	if($scope.queryIndex < $scope.selectedTypes.length)
            	{
	            	var currentMetadataType = $scope.selectedTypes[$scope.queryIndex];
	            	
            		console.log('Query----'+currentMetadataType);
            		$scope.showMessage('Retrieving Changes for '+currentMetadataType+'...','INFO');
            		var query = {};
	            	query.metaType = currentMetadataType;
	            	query.metaFolder = '';
	            	var queryLiStr = JSON.stringify([query]);
	            	
	            	Visualforce.remoting.Manager.invokeAction(
						'{!$RemoteAction.ProfileSnapshotController.listMetadataComponents}',
						JSON.stringify([query]),
						$scope.orgDetailId,
						function(result,err) {
				        	if(err.status)
						    {
						    	var tempLi = [];
						    	for(var index in result)
	                            {
	                            	if(index < result.length)
	                            	{
	                                	var meta = result[index];
	                                	if($scope.validateMetadataItem(meta))
	                                	{
	                                    	tempLi.push(meta);
	                                	}
	                            	}
	                            }
	                            if(tempLi.length > 0)
						    		$scope.filteredMetaDataItems[currentMetadataType] = tempLi;
						    	$scope.continueQuery();
						    }
						    else
						    {
						    	//return $scope.showMessage(err.message,'ERROR');
                                   console.log(err.message);
                                   $scope.continueQuery();
						    }
					});
            	}
            	else
            	{
            		$scope.finishFilterMetaItems();
            	}
            };
            
            $scope.continueQuery = function() {
            	$scope.queryIndex++;
            	$scope.listSimpleMetadataTypeOneByOne();
            };
            
            /**********************************************************************/
            /****************************Pagination Methods****************************/
            $scope.refreshOrderBy = function(orderVal) {
                $scope.metaOffSet = 0;
                $scope.viewLimit = $scope.metaOffSet + $scope.staticLimit;
                if(orderVal == $scope.orderByColumn)
                    $scope.isReverse = !$scope.isReverse;
                else
                {
                    $scope.isReverse = false;
                    $scope.orderByColumn = orderVal;
                }
                $scope.defaultNextPrevious();
            };
            
            $scope.showFirst = function() {
                $scope.metaOffSet = 0;
                $scope.viewLimit = $scope.staticLimit;
                $scope.defaultNextPrevious();      
            };
            
            $scope.listPrevious = function() {
                $scope.metaOffSet = $scope.metaOffSet - $scope.staticLimit;
                if ($scope.metaOffSet < 0)
                    $scope.metaOffSet = 0;
                $scope.viewLimit = $scope.metaOffSet + $scope.staticLimit;
                $scope.defaultNextPrevious();
            };
            
            $scope.listNext = function(tempTotal) {
                if (($scope.metaOffSet + $scope.staticLimit) < tempTotal)
                {
                    $scope.metaOffSet = $scope.metaOffSet + $scope.staticLimit;
                    $scope.viewLimit = $scope.metaOffSet + $scope.staticLimit;
                }
                $scope.defaultNextPrevious();
            };
            
            $scope.showLast = function(tempTotal) {
                $scope.metaOffSet = tempTotal - (tempTotal % $scope.staticLimit);
                if($scope.metaOffSet == tempTotal && $scope.metaOffSet != 0)
                {
                    $scope.metaOffSet = tempTotal - $scope.staticLimit;
                }
                $scope.viewLimit = $scope.metaOffSet + $scope.staticLimit;
                $scope.defaultNextPrevious();
            };
            
            $scope.checkItemAll = function(isAllChecked,compLi,offset) {
                 for(var index = offset ; index < (offset+$scope.staticLimit) && index < compLi.length  ; index++) {
                    if(isAllChecked)
                        compLi[index].checked = true;
                    else
                        compLi[index].checked = false;  
                 }
            };
            
            $scope.checkUnCheck = function(compLi,offset) {
                var flag = true;
                var index;
                for(var index = offset ; index < (offset+$scope.staticLimit) && index < compLi.length  ; index++) {
                    if( ! compLi[index].checked ) {
                        flag = false;
                        break;
                    }
                }
                $scope.isAllChecked = flag ;
                return flag;
            };
            
            $scope.defaultNextPrevious = function(){
                $scope.isAllChecked = false ;
            }
            
            $scope.isPrevious = function() {
                if($scope.metaOffSet < 1) 
                    return true;
                else {
                    return false;
                }
            };
            
            $scope.isNext = function(tempTotal){
                if(tempTotal > $scope.metaOffSet+$scope.staticLimit){
                    return false;
                }
                else {
                    return true;
                }
            };
            
            $scope.totalPageCount = function(tempTotal){
                var totalPage = parseInt(tempTotal % $scope.staticLimit > 0 ? (tempTotal / $scope.staticLimit)+1 : (tempTotal / $scope.staticLimit));
                return totalPage;
                
            };
            
            $scope.currentPageNo = function(tempTotal){
                var currentPage = 1;
                if($scope.metaOffSet <  $scope.staticLimit)
                    currentPage =  1;
                else
                {
                    currentPage = Math.ceil($scope.metaOffSet / $scope.staticLimit)+1;
                }
                return currentPage;
            };
            /**********************************************************************/
            /****************************Filter Methods****************************/
            $scope.filterForSearch = function(meta){
                if($scope.selectedMetadataType != '' && meta.type != $scope.selectedMetadataType)
                {
                    return false;
                }
                return true;
            }

            /**********************************************************************/
            /****************************Utility Methods*****************************/
            
            $scope.validateMetadataItem = function(meta) {
            	//console.log(meta);
            	if(meta.fullName != undefined && meta.type != undefined 
            		&& meta.fileName != undefined && meta.lastModifiedDate != undefined)
            	{
            		var metaLastModifiedDate = new Date(meta.lastModifiedDate).getTime();
            		return true;
            	}
            	return false;
            };
	        
	        $scope.showMessage = function(Message_Str,Message_Type) {
	        	var parentVal = $("[id$='msg']");
				if(parentVal != undefined)
				{
				    parentVal.html('');
				    if(Message_Str != '')
				    {
					    if(Message_Type == 'ERROR')
					    {
					    	var childVal = '<span id="j_id0:msg:j_id19:j_id20:0:j_id21">'+
											'<div class="message errorM3" role="alert">'+
												'<table border="0" cellpadding="0" cellspacing="0" class="messageTable" style="padding:0px;margin:0px;">'+
													'<tbody>'+
														'<tr valign="top">'+
															'<td><img alt="ERROR" class="msgIcon" src="/s.gif" title="ERROR"></td>'+
															'<td class="messageCell">'+
																'<div id="j_id0:msg:j_id19:j_id20:0:j_id21:j_id22:j_id24" class="messageText">'+
																	'<span id="j_id0:msg:j_id19:j_id20:0:j_id21:j_id22:j_id25" style="color:#cc0000">'+
																		'<h4>Error:</h4>'+
																	'</span>'+Message_Str+'<br>'+
																'</div>'+
															'</td>'+
														'</tr>'+
														'<tr>'+
															'<td></td>'+
															'<td></td>'+
														'</tr>'+
													'</tbody>'+
												'</table>'+
											'</div>'+
										'</span>';
							parentVal.append(childVal);
							$scope.disableUi = false;
					    }
					    else if(Message_Type == 'INFO')
					    {
							var childVal = '<span id="j_id0:msg:j_id19:j_id20:0:j_id21">'+
												'<div class="message infoM3" role="alert">'+
													'<table border="0" cellpadding="0" cellspacing="0" class="messageTable" style="padding:0px;margin:0px;">'+
														'<tbody>'+
															'<tr valign="top">'+
																'<td><img alt="INFO" class="msgIcon" src="/s.gif" title="INFO"></td>'+
																'<td class="messageCell">'+
																	'<div id="j_id0:msg:j_id19:j_id20:0:j_id21:j_id22:j_id24" class="messageText">'+
																		'<span id="j_id0:msg:j_id19:j_id20:0:j_id21:j_id22:j_id25">'+
																			'<h4></h4>'+
																		'</span>'+Message_Str+'<br>'+
																	'</div>'+
																'</td>'+
															'</tr>'+
															'<tr>'+
																'<td></td>'+
																'<td></td>'+
															'</tr>'+
														'</tbody>'+
													'</table>'+
												'</div>'+
											'</span>';
							parentVal.append(childVal);
						}
					}
				}
	        };
	        
	        $scope.getRetrieveRequest = function() {
	        	var retrieveRequest = new Object();
				retrieveRequest.apiVersion = $scope.apiVersion;
				retrieveRequest.singlePackage = true;
				retrieveRequest.unpackaged = {};
				retrieveRequest.unpackaged.types = [];
	        	return retrieveRequest;
	        };
			
			$scope.createConnection = function(accessToken,instanceUrl) {
				var conn =  new jsforce.Connection({
				  accessToken : accessToken,
	              proxyUrl: "/services/proxy",
	              //logLevel: "DEBUG",
				  //refreshToken : refreshToken,
				  serverUrl: instanceUrl});
				conn.metadata.pollTimeout = 18000000;
        		conn.metadata.pollInterval = 300000;
        		return conn;
			};
	        /**********************************************************************/
	        //Default init()
	        //$scope.CommitStep == 2;
            //$scope.filterOrgComponents();
        });
	</script>
</apex:page>