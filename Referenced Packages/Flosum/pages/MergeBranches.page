<apex:page standardController="Flosum__Branch__c" extensions="Flosum.MergeBranchesController" sidebar="false"  doctype="html-5.0" cache="false" tabStyle="Flosum__Branch__c" id="pg">
<!--     <c:TrackPanel /> -->
	<apex:includeScript value="{!URLFOR($Resource.Flosum__jszipmaster,'jszip-master/flosumsf/flosumsf1.6.0.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__jszipmaster, 'jszip-master/dist/jszip.min.js')}"/>
	<!-- 		added resources		 -->
    <apex:stylesheet value="{!URLFOR($Resource.Flosum__Merge, 'Merge/css/bootstrapSF.min.css')}" />
    <apex:includeScript value="{!URLFOR($Resource.Flosum__ContentEditor, 'beauty/forMatXML.js')}"/>
    
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/jquery-2.1.4.min.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/angular.min.js')}"/> 
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/difflib.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/diffxmllib.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/angular-base64.min.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/deep-diff-0.3.3.min.js')}"/>
    
    <script src="{!$Resource.X2JS}"></script>
    <script src="{!$Resource.DiffJS}"></script>

    <!-- for new panel -->
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/bootstrap.min.js')}"/> 
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/angular-animate.min.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/angular-route.min.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/angular-aria.min.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/angular-messages.min.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/svg-assets-cache.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/angular-material.min.js')}"/>
	<apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/pako.min.js')}"/>
    <apex:stylesheet value="{!URLFOR($Resource.Flosum__Merge, 'Merge/css/angular-material.min.css')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/angular-modal-service.min.js')}"/>
 	<apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/editor.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/bkup.js')}"/>
    <apex:includeScript value="{!URLFOR($Resource.Flosum__Merge, 'Merge/fullbkup.js')}"/>
 	
    <apex:stylesheet value="{!URLFOR($Resource.Flosum__Merge, 'Merge/css/style.css')}"/>
  
    <style type="text/css" media="screen">
		.activeTab {background-color:#236FBD; color:white;  tab-color:yellow; background-image:none}
      	.inactiveTab {background-color:white; color:black; 	background-image:none}
      	body .bPageTitle .ptBody h1.noSecondHeader {
		    color: #FFF;
		}
        .pagination { 
            padding: 1%; 
        } 
        div .pagination { 
            text-align: center; 
        } 
        td .dataCell label { 
            font-weight: normal; 
        } 
        span.paginationEle { 
            margin-left: 4px; 
        } 
        .pagination input { 
            margin-left: 4px; 
        } 
        hr.pBlockDescription {
            margin-top: 0%;
            border-bottom: 1px solid #DBDBDB;
        }
        tr {
            display: table-row;
            vertical-align: inherit;
            border-color: inherit;
        }
        .EmpyBlock {
            height: 18px;
        }
        .bundle_error_msg {
          	display: none;
          	padding: 5px;
            color: #FF4500;
          	background-color: #ffffb3;
          	text-align: center;
          	font-size: 16px;
          	width: 100%;
        }
        .virtualRepeatdemoVerticalUsage .md-virtual-repeat-container .md-virtual-repeat-offsetter div {
        	    padding-left: initial;
       	        padding-top: initial;
       	        vertical-align: sub;
        }
        .virtualRepeatVerticalUsageXml .md-virtual-repeat-container .md-virtual-repeat-offsetter div {
 			   padding-left: initial;
		}
		.virtualRepeatVerticalUsageXml .header .headerTitle {
  		  	font-weight: bolder; font-size:14px; width:400px; float:left; text-align:center; 
  		}
 
		.virtualRepeatVerticalUsageXml .header .headerButtonPlaceholder  {
		    width:400px; float:left; text-align:center;
  		}

		.virtualRepeatVerticalUsageXml .headerButton  {
		    width:700px; float:left; text-align:center;
  		}
  	    /************* ReWrite MODAL STYLES  *************/

		.modal-backdrop.in {
    		opacity: 0;
    	}
 		.modal.fade .modal-dialog, .modal.in .modal-dialog {
  			transform: translateY(200px);
			 transition: 0.1s;
		}
		.modal-open, .modal-open .navbar-fixed-top {
   			overflow: hidden;
			 padding-right: 0 !important;
		}
  		
 		#ruler { visibility: hidden; white-space: nowrap; font-family: monospace; font-size: 12px;}  
  		#ruler-xml { visibility: hidden; white-space: nowrap; font-family: monospace; font-size: 12px;}  
  
  		.btn-warning:hover, .btn-warning:focus, .btn-warning:active, .btn-warning.active, .open>.dropdown-toggle.btn-warning {
  			color: #000;
  		} 
  		.btn-success:hover, .btn-success:focus, .btn-success:active, .btn-success.active, .open>.dropdown-toggle.btn-success {
  			color: #000;
  		} 
    
	</style>
    <c:Wait />  
 	<c:DynamicLookupScript />

    <apex:pagemessages id="msg"/>
	<apex:form id="allCompForm">
	<apex:outputPanel id="jspanel"> 
 	 <script>  
 	 	function mergeComplete(error, msg, batchJobId){
    	// analyse results
    	//  errorCode = 1 : correctable
    	//  errorCode > 10 : uncorrectable
    	// check are errors on previous steps
    	if (errors) return;
    	////////console.log('mergeComplete, errors: '+error +' msg:'+msg);
    	if (error > 0){
			showErrorMessage(msg);
		}else{
			setMessageOnPage(msg);// init job message
		}
		if (error > 10 || error < 0){// uncorrectable error || complete; disable all page elements
			getScope().disableUI(true);
			// goto refresh status cycle
			refreshStatus(batchJobId);
		}else{
			getScope().disableUI(false);
		}
    }
	</script>
   </apex:outputPanel>	
		<apex:actionfunction name="addToBranch" action="{!addToBranch}" onComplete="startZipCreation('{!errorCode}','{!JSENCODE(msg)}');" reRender="none">
			<apex:param assignTo="{!targetBranchName}" value="" name="targetBranchName"/>
		</apex:actionfunction>
		<apex:actionfunction name="branchZipCreator" action="{!branchZipCreator}" onComplete="processZipCreation('{!errorCode}','{!logId}','{!logAttId}','{!patchListJSON}','{!logsListJSON}','{!validateOnly}', '{!srcBranchNameEsc}', '{!JSENCODE(message)}');" reRender="none">
		</apex:actionfunction>
		<apex:actionfunction name="complete" action="{!complete}" />
		<apex:actionfunction name="finalCall" action="{!finalCall}" onComplete="mergeComplete('{!errorCode}','{!JSENCODE(msg)}', '{!batchJobId}');" reRender="none">
		</apex:actionfunction>
        <apex:actionfunction name="insertMergeAttachment" action="{!insertMergeAttachment}" rerender="msg" oncomplete="handleMergeDml();">
            <apex:param assignTo="{!jsonStr}" value="" name="newstr"/>
        	<apex:param assignTo="{!patchId}" value="" name="patchId"/>
        </apex:actionfunction>
		
        <div ng-app="mergeCommit">               
         <div ng-controller ="MergeBranchesControllerAJS"  id="angularControllerId">
           <div class="ng-cloak">
  		
	        <script type="text/ng-template" id="custom.html">
		       <div class="modal" id="modalDialog1" style="transition: 0s; padding-right: 0px;">
				  <div class="modal-dialog">
    				 <div class="modal-content">
      					<div class="modal-header">
        					<button type="button" class="close" ng-click="close(false)" data-dismiss="modal" aria-hidden="true">&times;</button>
        					<h4 class="modal-title">Resolving conflict</h4>
      					</div>
      					<div class="modal-body">
        					<p>The components with types Document, StaticResource are not editable in current version of Flosum.</p>
							<p> Choose how to resolve the conflict:</p>
      					</div>
	  					<div style="padding-left: 20px;"> 
	  						<div ng-init="question.selected = 1">
           						<label data-ng-repeat="choice in question.choices">
 					 				<input type="radio" name="response" data-ng-model="question.selected" data-ng-value="{{choice.id}}" />
 				 						{{choice.text}}
 				 						<br/>
								</label>
            				</div>
	  					</div>
 	  					<div style="padding-left: 20px;"> 
							<input type="checkbox" class="psli" ng-model="alwaysDo">Apply the same action for all similar components</input>
						</div>
     					<div class="modal-footer" style="text-align:center;">
        					<button type="button" ng-click="close(false)" class="btn btn-warning" data-dismiss="modal">Cancel</button>
        					<button type="button" ng-click="close(true)" class="btn btn-success" data-dismiss="modal">Apply</button>
      					</div>
    				</div>
  				</div>
			  </div>
     		</script> 
	        
	        <!--  block for tables display  -->
            <apex:pageBlock html-ng-show="CommitStep == 0" id="FirstPageBlock"> 
  		    <apex:sectionHeader title="Merge Branches" description="Used to merge branch" />
  		    <div html-ng-show="isLoading" class="loading-indicator" ng-cloak="" id="spinner"></div>
  		    
	    	<apex:pageBlock id="branchblock">
				<apex:pageBlockSection columns="1" id="pbs2">
					<apex:pageBlockSectionItem >
        	            <apex:outputLabel value="{!$ObjectType.Flosum__Branch__c.fields.Name.label}" />
            	        <apex:outputField value="{!Flosum__Branch__c.Name}"/>
                	</apex:pageBlockSectionItem>
	                <apex:pageBlockSectionItem id="bsi2">
    	                <apex:outputLabel value="{!$ObjectType.Flosum__Branch__c.fields.Flosum__Branch_Name__c.label}" />
        	            <apex:outputField value="{!Flosum__Branch__c.Flosum__Branch_Name__c}" id="srcBranch"/>
            	    </apex:pageBlockSectionItem>
        	   	</apex:pageBlockSection>
				<apex:pageBlockSection columns="1" id="pbs1">
                	<apex:pageBlockSectionItem id="pbsi1">
                    	<apex:outputLabel value="Merge To Existing Branch" />
                		<apex:outputPanel >
			        	    <apex:inputHidden id="branchTargetId" value="{!branchId}" />
			            	<apex:inputText size="40" value="{!branchName}" id="branchTargetName"  onFocus="this.blur()" html-ng-disabled="branchNewTargetName != '' || disableAllUI"  html-callitafterchange=""/>           
		  		    		<img src="/s.gif" onclick="openLookupPopup('{!$Component.branchTargetName}','{!$Component.branchTargetId}','{!$ObjectType.Branch__c.Name}',
		  		    										'{!$ObjectType.Branch__c.fields.Branch_Name__c.Name}','{!srcBranchNameEsc}','emptysearch'); return false" 
				            	class="lookupIcon"
				            	onmouseout="this.className='lookupIcon';" 
				            	alt="Patch Name Lookup (New Window)" 
			    	        	onmouseover="this.className='lookupIconOn';"
			    	        	ng-show="branchNewTargetName == '' && !disableAllUI"/>
		  		   		</apex:outputPanel>
                	</apex:pageBlockSectionItem>
        	   	</apex:pageBlockSection>
				<apex:pageBlockSection columns="1" id="pbs3">
                	<apex:pageBlockSectionItem id="pbsi2" html-ng-show="!onlyExistingBranches">
                    	<apex:outputLabel value="Merge To New Branch" />
                		<apex:outputPanel >
			            	<apex:inputText size="40" html-ng-model="branchNewTargetName" id="branchNewTargetName"  html-ng-disabled="disableAllUI" />           
		  		   		</apex:outputPanel>
                	</apex:pageBlockSectionItem>
 	                <apex:pageBlockSectionItem >
    	                <apex:outputLabel value="Force commit (commit the version in the Branch as-is)"/>
        	            <input type="checkbox" ng-click="overallChanges();" class="psli"  ng-model="bOverwriteAll" html-ng-disabled="disableAllUI"/>
            	    </apex:pageBlockSectionItem>
        	   	</apex:pageBlockSection>
				<apex:pageBlockButtons location="bottom" id="pbb1">
				   	<apex:commandbutton value="Cancel" action="{!back}" reRender="msg"  id="button2" />
					<apex:commandButton value="Merge To Branch" onClick="mergeBranches();" reRender="none"  html-ng-disabled="mergeButton" id="button1"/>
				</apex:pageBlockButtons>
			</apex:pageBlock>
			
		<!-- start new table output  based on angularJs -->
	<apex:outputPanel html-ng-show="enableTables && branchNewTargetName == ''" id="form1">
            <apex:pageblock >
            	<apex:facet name="header">
		            <table width="100%">
        		      <tr>
                		  <td align="left"><h4>{!$Label.Conflict_Merge_Components_Section_Title}&nbsp;&nbsp;&nbsp;</h4>
                		  	<div class="mouseOverInfoOuter" id="searchInvoiceHelper" onfocus="addMouseOver(this)" onmouseover="addMouseOver(this)" tabindex="0">
	   				 			<img src="/s.gif" alt="" class="infoIcon" title="" />
	    							<div class="mouseOverInfo" id="searchInvoiceHelperText" style="display: none; opacity: -0.19999999999999996; left: 16px;">
	        							<div class="body">{!$Label.Conflict_Merge_Components_Section_Description} {!$Label.Repo_Conflict_Components_Section_Description_2}</div>
	   							    </div>
	   						</div>	    
						  </td>
			              <td align="right"><a ng-click="showHideComponentList();" style="cursor: pointer;">{{componentListShow ? 'hide':'show'}}</a></td>
        		      </tr>
		            </table>
        		</apex:facet>
                <table ng-show="componentListPtr.length > 0 && componentListShow" class="list">
                	<thead>
                    	<tr class="headerRow">
                             <th>No.</th>
                             <th><input type="checkbox" ng-click="checkUncheck(componentListPtr,1);" class="psli" ng-model="isAllChecked1" >&nbsp;</input></th>
                             <th ng-repeat = "(key, value) in fieldSet1">
                                <a ng-click="safe.refreshOrderBy(key)">{{ safe.orderByColumn == key ? safe.isReverse ? value+' ▼' : value+' ▲' : value }}</a>
                             </th>
                             <th class="Label" style="text-align: center;">
                             	<a ng-click="safe.refreshOrderBy('compare')">{{safe.orderByColumn == 'compare' ? safe.isReverse ? 'Compare ▼' : 'Compare ▲': 'Compare'}}</a>
                             </th>
                        </tr>
                    </thead>
                    <tbody>
                       <tr ng-repeat = "item in componentListPtr |  orderBy: safe.orderByColumn : safe.isReverse | limitTo: safe.viewLimit" ng-if="$index >= safe.metaOffSet" class="dataRow" onmouseover="if (window.hiOn){hiOn(this);} " onmouseout="if (window.hiOff){hiOff(this);} ">
                            <td>{{ $index+1 }}</td>
                            <td><input type="checkbox" name="selectedComps[]" value="{{ item['compId'] }}" ng-model="item['check']" /></td>
                            <td ng-repeat = "(key, value) in fieldSet1">
                                 {{ item[key] }}
                            </td>
                            <td style="text-align: center;">
                                 <span ng-show="true" ng-style="(item.isConflict && {'color':  'red'}) || (item.isAutoResolved && {'color':  'green'})" style="cursor:pointer;" ng-click="getMergeInfo(item);">{{item['compare']}}</span>
                            </td> 
                        </tr>
                    </tbody>
                </table>
                <apex:outputPanel html-ng-show="componentListPtr.length > 0 && componentListShow" styleClass="pagination" layout="block" style="text-align: center;">
                   <apex:commandbutton html-ng-click="safe.showFirst();" onClick="return false;" value="First" reRender="none" html-ng-disabled="safe.isPrevious() || disableNextPrevious"/>
                   <apex:commandbutton html-ng-click="safe.listPrevious();" onClick="return false;" value="Previous" reRender="none" html-ng-disabled="safe.isPrevious() || disableNextPrevious" />
                   Total {{(componentListPtr).length}} component(s), Page {{safe.currentPageNo((componentListPtr).length)}} of {{safe.totalPageCount((componentListPtr).length)}}
                   <apex:commandbutton html-ng-click="safe.listNext((componentListPtr).length);" onClick="return false;" value="Next" reRender="none" html-ng-disabled="safe.isNext((componentListPtr).length) || disableNextPrevious"/>
                   <apex:commandbutton html-ng-click="safe.showLast((componentListPtr).length);" onClick="return false;" value="Last" reRender="none" html-ng-disabled="safe.isNext((componentListPtr).length) || disableNextPrevious"/>
                </apex:outputPanel>
                <div style="width: 100%;float: center; padding: 5px;text-align: center;" ng-show="componentListPtr.length == 0 && componentListShow">
                      <strong>No records to display</strong>
                </div>
            </apex:pageblock>
            
 
            
            <apex:pageblock >
            	<apex:facet name="header">
		            <table width="100%">
        		      <tr>
                		  <td align="left"><h4>{!$Label.Not_Merge_Components_Section_Title}&nbsp;&nbsp;&nbsp;</h4>
                		  	<div class="mouseOverInfoOuter" id="searchInvoiceHelper" onfocus="addMouseOver(this)" onmouseover="addMouseOver(this)" tabindex="0">
	   				 			<img src="/s.gif" alt="" class="infoIcon" title="" />
	    							<div class="mouseOverInfo" id="searchInvoiceHelperText" style="display: none; opacity: -0.19999999999999996; left: 16px;">
	        							<div class="body">{!$Label.Not_Merge_Components_Section_Description}</div>
	   							    </div>
	   						</div>	    
						  </td>
			              <td align="right"><a ng-click="showHidenotMergeCompList();" style="cursor: pointer;">{{notMergeCompListShow ? 'hide':'show'}}</a></td>
        		      </tr>
		            </table>
        		</apex:facet>
                <table ng-show="notMergeCompList.length > 0 && notMergeCompListShow" class="list">
                	<thead>
                    	<tr class="headerRow">
                             <th>No.</th>
                             <th ng-repeat = "(key, value) in fieldSet2">
                                <a ng-click="notCommit.refreshOrderBy(key)">{{ notCommit.orderByColumn == key ? notCommit.isReverse ? value+' ▼' : value+' ▲' : value }}</a>
                             </th>
                        </tr>
                    </thead>
                    <tbody>
                       <tr ng-repeat = "item in notMergeCompList |  orderBy: notCommit.orderByColumn : notCommit.isReverse | limitTo: notCommit.viewLimit" ng-if="$index >= notCommit.metaOffSet" class="dataRow" onmouseover="if (window.hiOn){hiOn(this);} " onmouseout="if (window.hiOff){hiOff(this);} ">
                            <td>{{ $index+1 }}</td>
                            <td ng-repeat = "(key, value) in fieldSet2">
                                 {{ item[key] }}
                            </td>
                        </tr>
                    </tbody>
                </table>
                <apex:outputPanel html-ng-show="notMergeCompList.length > 0 && notMergeCompListShow" styleClass="pagination" layout="block" style="text-align: center;">
                   <apex:commandbutton html-ng-click="notCommit.showFirst();" onClick="return false;" value="First" reRender="none" html-ng-disabled="notCommit.isPrevious() || disableNextPrevious"/>
                   <apex:commandbutton html-ng-click="notCommit.listPrevious();" onClick="return false;" value="Previous" reRender="none" html-ng-disabled="notCommit.isPrevious() || disableNextPrevious" />
                   Total {{(notMergeCompList).length}} component(s), Page {{notCommit.currentPageNo((notMergeCompList).length)}} of {{notCommit.totalPageCount((notMergeCompList).length)}}
                   <apex:commandbutton html-ng-click="notCommit.listNext((notMergeCompList).length);" onClick="return false;" value="Next" reRender="none" html-ng-disabled="notCommit.isNext((notMergeCompList).length) || disableNextPrevious"/>
                   <apex:commandbutton html-ng-click="notCommit.showLast((notMergeCompList).length);" onClick="return false;" value="Last" reRender="none" html-ng-disabled="notCommit.isNext((notMergeCompList).length) || disableNextPrevious"/>
                </apex:outputPanel>
                <div style="width: 100%;float: center; padding: 5px;text-align: center;" ng-show="notMergeCompList.length == 0 && notMergeCompListShow">
                      <strong>No records to display</strong>
                </div>
            </apex:pageblock>
        </apex:outputPanel>
        </apex:pageBlock>
        <!--  			Comparison panels markup		: apex	code				 -->
         <apex:pageBlock html-ng-show="CommitStep == 2">
          <span id="ruler" >abcdefghij</span>
          <div ng-if="CommitStep == 2" postrender-action="inittxtpanel()"/>      
          <div class="bPageTitle" style="padding: 0px 0 0;">
           	<div class="ptBody">
	           	<div class="content">
          			<h1 class="pageType" style="margin-top:0px;">{{PopUp.compType}}</h1>
       				<h2 class="pageDescription" style="margin-top:0px;">{{PopUp.compName}}</h2>
           		</div>
	 		</div>
          </div>
          <div class="virtualRepeatdemoVerticalUsage" ng-cloak="" id="txtEditPanel">
            <md-content layout="column">
		      <div class="Legend">
        		  <div class="Updated">&nbsp;</div> Updated
		          <div class="Created">&nbsp;</div> Created
        		  <div class="Deleted">&nbsp;</div> Deleted
        		  <div >► &nbsp; Restore the line from the target branch</div>
        		  <div >◄ &nbsp; Remove this line</div>
		          <div > <input type="checkbox" ng-click="changeView(1);" class="psli" ng-model="editor.changesOnly" >&nbsp;</input>
                                <label>Show only changed lines</label>
				  </div>
 				  <div > <input type="checkbox" ng-click="changeView(2);" class="psli" ng-model="editor.ignoreWS" >&nbsp;</input>
                                <label>Ignore white spaces</label>
				  </div>
              </div>
              
              <div style="float:center; text-align:center;margin:auto;">
           		  <button class="btn btn-warning btn-footer"  id="btn1u" type="button" ng-click="cancel()">Cancel</button>&nbsp; 
            	  <button class="btn btn-success btn-footer"  id="btn2u" type="button"  ng-click="applyChangesTxt()">Apply</button> 
 		      	  <button class="btn btn-warning btn-footer"  id="btn4" type="button" ng-click="edit(1,false)">Manual Edit</button>
          	  </div>
              

              <div class="header">
              <div>
		        <!-- 			Left panel			-->
        			<div class="headerTitle">{{ targetBranchName}} <br/> {{targetDetails}}
        			</div>
			   <!--      <span class="headerButtonPlaceholder"> &nbsp;&nbsp;&nbsp;&nbsp; </span> -->
       				<span  class="headerButton" >
        		    	<span  ng-show="!editor.copyAllFlag" style="cursor: pointer;"  ng-click="copyAll(true)">►</span>
				        <span  ng-show="editor.copyAllFlag"  style="cursor: pointer;" ng-click="copyAll(false)">◄</span>
		        	</span>
        		<!-- 			Right panel			-->
		      	    <div class="headerTitle" >{{ sourceBranchName}} <br/> {{sourceDetails}}
		      	    </div>
    		    </div>
    		    </div>
    
              <md-virtual-repeat-container id="vertical-container-txt">
 		 	<div ng-if="CommitStep == 2 && isEqual"  style="width: 100%;float: center; padding: 5px;text-align: center; color:red;">
	   			<span> These Apex components are equal</span>
  	  		</div>
                <div md-virtual-repeat="row in  editor.viewCollection" class="repeated-row" flex="" md-item-size="24">

                  <div class="repeated-row-item" >
                  <!-- 			Left panel			-->
                    <div style="width:48%;float:left;"  >
                      <div style="padding-left:0px;">&nbsp;{{row.number1}}	</div>

                      <div ng-if = "row.OldData" ng-style="row.DiffAction ? STYLE_UPDATED:  row.Diffstyle">
                        <span style="white-space: pre; font-family: monospace; font-size: 12px;">  {{row.OldData}}</span>
                      </div>


                      <div ng-if="row.DiffType != 'unchanged' && !row.isKey" style="float:right;cursor: pointer;">
                        <div ng-if="row.DiffType == 'created' && !row.DiffAction && row.guid">
                            <span class="" ng-click="updated(row.number)">◄</span>
                        </div>
                        <div ng-if="row.DiffType == 'deleted' && !row.DiffAction && row.guid">
                            <span class="" ng-click="updated(row.number)">►</span>
                        </div>
                        <div ng-if="row.DiffType == 'created' && row.DiffAction && row.guid">
                            <span class="" ng-click="updated(row.number)">►</span>
                        </div>
                        <div ng-if="row.DiffType == 'deleted' && row.DiffAction && row.guid">
                            <span class="" ng-click="updated(row.number)">◄</span>
                        </div>
                        <div ng-if="row.DiffType == 'updated' && !row.DiffAction && row.guid">
                            <span class="" ng-click="updated(row.number)">►</span>
                        </div>
                        <div ng-if="row.DiffType == 'updated' && row.DiffAction && row.guid">
                            <span class="" ng-click="updated(row.number)">◄</span>
                        </div>
                      </div>

                    </div>
                    <div style="width:1%;float:left; border-left: 1px solid grey; height: 24px;" ></div>

                    <!-- 			Right panel			-->
                    <div ng-if = "row.DiffViewValue ||  row.DiffAction" style="width:48%;float:left;" >
                      <div style="padding-left:0px;">&nbsp;{{row.number2}}	</div>
                      <div>
                        <span style="white-space: pre;font-family: monospace; font-size: 12px;" ng-style="row.DiffAction ? STYLE_UPDATED: row.Diffstyle">{{row.DiffViewValue}}</span>
                      </div>
                    </div>
                  </div> 


                </div>

              </md-virtual-repeat-container>
            </md-content>


          </div>

  
          <div style="float:center; text-align:center;margin:auto;">
            <button class="btn btn-warning btn-footer"  id="btn1d" type="button" ng-click="cancel()">Cancel</button>&nbsp; 
            <button class="btn btn-success btn-footer"  id="btn2d" type="button"  ng-click="applyChangesTxt()">Apply</button> 
       	    <button class="btn btn-warning btn-footer"  id="btn4" type="button" ng-click="edit(1,false)">Manual Edit</button>
          </div>

        </apex:pageBlock>
   

        <!--  			Bundle Comparison panel markup							 -->
        <apex:pageBlock html-ng-show="CommitStep == 4">
            <div class="bPageTitle" style="padding: 0px 0 0;">
           	<div class="ptBody">
	           	<div class="content">
          			<h1 class="pageType" style="margin-top:0px;">{{PopUpInfo.compType}}</h1>
       				<h2 class="pageDescription" style="margin-top:0px;">{{PopUpInfo.compName}}</h2>
           		</div>
	 		</div>
            </div>
            <div class="sf-inner-container" style="width: 100%;     padding-top: 0px;  padding-bottom: 20px;">
               	<div class ="bundle_error_msg"> Resolve conflicts for all bundle components first</div>
                <div style="text-align: center; width: 100%; padding-bottom: 20px;">
                    <button type="button" class="btn btn-warning" style="width: 15%;" ng-click="PopUpInfo.closeBundleManualMerge()">Cancel</button>
                    <button type="button" style="background-color: #2A94D6; width: 15%;" class="btn btn-success" ng-click="PopUpInfo.bundleManualMerge()">Apply Changes</button>
                </div>
                <table ng-show="bundleList.length > 0" class="list">
 	              	<thead>
    	               	<tr class="headerRow">
                           <th style="text-align: center; width: 10%;">No.</th>
                           <th class="Label" style="text-align: center; width: 35%;">{{targetBranchName}} <br/> {{targetDetailsBundle}}&nbsp;</th>
                           <th class="Label" style="text-align: center; width: 5%;">&nbsp;</th>
                           <th class="Label" style="text-align: center; width: 35%;">{{sourceBranchName}} <br/> {{sourceDetailsBundle}}&nbsp;</th>
                           <th class="Label" style="text-align: center; width: 15%;">Compare&nbsp;</th>
                        </tr>
                    </thead>
                    <tbody>
                       <tr ng-repeat = "item in bundleList" class="dataRow">
                            <td style="text-align: center;">{{ $index+1 }}</td>
                            <td style="text-align: center;">{{ item['srcCompName'] }}</td>
                            <td style="text-align: center;">
                            	<div ng-if="(item.conflictCode == 4 && item.moved) || (item.conflictCode == 3 && item.moved)">
                            		<span class="" ng-click="updateBundle(item)">◄</span>
                        		</div>
                            	<div ng-if="(item.conflictCode == 4 && !item.moved) || (item.conflictCode == 3 && !item.moved)">
                            		<span class="" ng-click="updateBundle(item)">►</span>
                        		</div>
                            </td>
                            <td style="text-align: center;">
                            	<div ng-if="!(item.conflictCode == 3 && item.moved)">
                            		{{ item['tgtCompName'] }}	
                        		</div>
                            	<div style="    background-color: #ffffb3;" ng-if="item.conflictCode == 3 && item.moved">
                            		delete {{ item['tgtCompName'] }}	
                        		</div>
                        		<div style="    background-color: #ffffb3;" ng-if="item.conflictCode == 4 && item.moved">
                            		Add {{ item['srcCompName'] }}	
                        		</div>
                            </td>
                            <td style="text-align: center;">
                                 <span style="cursor: pointer; color:red" ng-click="getMergeInfo(item);" ng-show="item.isConflict && item.conflictCode == 1">Conflict</span>
                                 <span style="cursor: pointer; color:green" ng-click="getMergeInfo(item);" ng-show="!item.isConflict && item.conflictCode == 2">Merged</span>
                                 <span  ng-show="item.conflictCode == 3">New</span>
                                 <span  ng-show="item.conflictCode == 4">Deleted</span>
                                 <span style="color:green" ng-show="item.conflictCode == 0">Equal</span>
                            </td> 
                        </tr>
                    </tbody>
                </table>
            </div>   
       </apex:pageBlock>
        
       <!--  			XML Comparison panel markup							 -->
       <apex:pageBlock html-ng-show="CommitStep == 3">
          <span id="ruler-xml" >abcdefghij</span>
		  <div ng-if="CommitStep == 3" postrender-action="initxmlpanel()"/> 
          <div class="bPageTitle" style="padding: 0px 0 0;">
           	<div class="ptBody">
	           	<div class="content">
          			<h1 class="pageType" style="margin-top:0px;">{{PopUp.compType}}</h1>
       				<h2 class="pageDescription" style="margin-top:0px;">{{PopUp.compName}}</h2>
           		</div>
	 		</div>
          </div>
		  <div class="virtualRepeatVerticalUsageXml" ng-cloak="" id="xmlEditPanel">
			<md-content layout="column">
                <div class="Legend">
	 				<div class="Updated">&nbsp;</div>Updated
  					<div class="Created">&nbsp;</div>Created
			  		<div class="Deleted">&nbsp;</div>Deleted
  	        		<div >► &nbsp; Restore the line from the target branch</div>
        		    <div >◄ &nbsp; Remove this line</div>
					<div > <input type="checkbox" ng-click="changeView(1);" class="psli" ng-model="editor.changesOnly" >&nbsp;</input>
                                <label>Show the reduced XML tree</label>
					</div>
				</div>
     
     			<div style="float:center; text-align:center;margin:auto;">
			       <button class="btn btn-warning btn-footer"  id="btn1u" type="button" ng-click="cancel()">Cancel</button>&nbsp; 
       			   <button class="btn btn-success btn-footer"  id="btn2u" type="button"  ng-click="applyChangesXml()" ng-disabled="!isXmlValid">Apply</button> 
 		       	   <button class="btn btn-warning btn-footer"  id="btn4" type="button" ng-click="edit(0,false)">Manual Edit</button>
    			</div>
                
	  			<div class="header">
              <div>
		        <!-- 			Left panel			-->
        			<div class="headerTitle">{{ targetBranchName}} <br/> {{targetDetails}}
        			</div>
			   <!--      <span class="headerButtonPlaceholder"> &nbsp;&nbsp;&nbsp;&nbsp; </span> -->
       				<span  class="headerButton" >
        		    	<span  ng-show="!editor.copyAllFlag" style="cursor: pointer;"  ng-click="copyAll(true)">►</span>
				        <span  ng-show="editor.copyAllFlag"  style="cursor: pointer;" ng-click="copyAll(false)">◄</span>
		        	</span>
        		<!-- 			Right panel			-->
		      	    <div class="headerTitle" >{{ sourceBranchName}} <br/> {{sourceDetails}}
		      	    </div>
    		    </div>
    		    </div>
    		<md-virtual-repeat-container id="vertical-container-xml">
	   		 	<div ng-show="CommitStep == 3 && isEqual && isXmlValid"  style="width: 100%;float: center; padding: 5px;text-align: center; color:red;">
		   			<span> These Xml components are equal</span>
    			</div>
 	   		 	<div ng-show="CommitStep == 3 && !isXmlValid"  style="width: 100%;float: center; padding: 5px;text-align: center; color:red;">
		   			<span> Error: Invalid XML structure in  component(s)</span>
    			</div>
   			   <div md-virtual-repeat="row in  editor.viewCollection" class="repeated-row-xml" flex="" md-item-size="22" ng-show="isXmlValid">

   				  <div class="repeated-row-xml-item" style="vertical-align: top; line-height: 22px;">
  			   		<!-- 			Left panel			-->
				   	<div style="width:48%;float:left;" >
				      	<div ng-if ="row.isKey" >
                			<div style="font-size: 24px; text-align:center;vertical-align: sub;">{{row.margin}}</div><span> {{row.displayedKey}}</span>
              			</div>
              			<div ng-if ="!row.isKey">
                			<div style="font-size: 24px;text-align:center;vertical-align: sub;">{{row.margin}}</div><span> {{row.displayedKey}}</span>
              
			                <div ng-if = "row.OldData"  ng-style="row.DiffAction ? STYLE_UPDATED:  row.Diffstyle">
			                	<span style=" border-bottom: 1px solid; border-top: 1px solid; border-left: 1px solid;border-right: 1px solid;vertical-align: top;     padding-left: 5px;    padding-right: 5px;">
	            			      
	            			      {{row.OldData}}</span>
                			</div>
              			</div>

				        <div ng-if="row.DiffType == 'updated' && !row.isKey" style="float:right;cursor: pointer;">
        					<div ng-if="row.DiffType == 'updated' && !row.isKey && !row.DiffAction && row.guid && row.number">
			        			<span class="" ng-click="updated(row.number)">►</span>
	        				</div>
			        		<div ng-if="row.DiffType == 'updated' && !row.isKey && row.DiffAction && row.guid && row.number">
        						<span class="" ng-click="updated(row.number)">◄</span>
	        				</div>
        				</div>
        	
				        <div ng-if="(row.DiffType == 'created' || row.DiffType == 'deleted') && !row.isKey" style="float:right;cursor: pointer;">
        					<div ng-if="row.DiffType == 'created' && !row.isKey && !row.DiffAction && row.guid && row.number">
			        			<span class="" ng-click="updated(row.number)">◄</span>
	        				</div>
			    	        <div ng-if="row.DiffType == 'deleted' && !row.isKey && !row.DiffAction && row.guid && row.number">
            					<span class="" ng-click="updated(row.number)">►</span>
			        	    </div>
        					<div ng-if="row.DiffType == 'created' && !row.isKey && row.DiffAction && row.guid && row.number">
			        			<span class="" ng-click="updated(row.number)">►</span>
	        				</div>
				            <div ng-if="row.DiffType == 'deleted' && !row.isKey && row.DiffAction && row.guid && row.number">
    	    				    <span class="" ng-click="updated(row.number)">◄</span>
			        	    </div>
        				</div>
	
			      </div>
				  <div style="width:1%;float:left; border-left: 1px solid grey; height: 22px;" ></div>
	
			      <!-- 			Right panel			-->
			      <div style="width:48%;float:left;" >
   				    <div ng-if ="row.isKey" >
         				<div style="font-size: 24px; text-align:center;vertical-align: sub;">{{row.margin}}</div><span> {{row.displayedKey}}</span>
       				</div>
			    	<div ng-if ="!row.isKey">
         				<div style="font-size: 24px;text-align:center;vertical-align: sub;">{{row.margin}}</div><span> {{row.displayedKey}}</span> 
         				<div ng-if = "row.DiffViewValue" ng-style="row.DiffAction ? STYLE_UPDATED: row.Diffstyle">
            				<span style="border-bottom: 1px solid; border-top: 1px solid; border-left: 1px solid;border-right: 1px solid;vertical-align: top;  padding-left: 5px;    padding-right: 5px;">
            				{{row.DiffViewValue}}</span>
         				</div>
       				</div>
     			  </div>
     			 <!-- 		end of 	Right panel			--> 
     		   </div> 
     	   	 </div>
          </md-virtual-repeat-container>
	   </md-content>

 	   <!-- isLoading  --> 
    </div>

    <div ng-show="CommitStep == 3 && isEquivalent"  style="width: 100%;float: center; padding: 5px;text-align: center; color:red;">
	   <span> These Xml components have a different crc32 sum, but do not differ  by structure (i.e. they are equivalent)</span>
    </div>


    <div style="float:center; text-align:center;margin:auto;">
       <button class="btn btn-warning btn-footer"  id="btn1d" type="button" ng-click="cancel()">Cancel</button>&nbsp; 
       <button class="btn btn-success btn-footer"  id="btn2d" type="button"  ng-click="applyChangesXml()" ng-disabled="!isXmlValid">Apply</button> 
   	   <button class="btn btn-warning btn-footer"  id="btn4" type="button" ng-click="edit(0,false)">Manual Edit</button>
    </div>
  </apex:pageBlock>
<!--  end of block for CommitStep3 -->
 
  </div>
 </div>
</div>
 
    <apex:actionfunction action="{!updateAttachments}"  name="uploadAttachments" onComplete="processResults('{!errorCode}');">
       <apex:param assignTo="{!uploadJson}" value="" name="uploadJson"/>
    </apex:actionfunction>
 
</apex:form>
   <script>
    const DEBUG_MODE = false;
    const ESCAPE_MODE = false;
    const CONSIDER_META = false;
    
    const AUTORESOLVED = 'Autoresolved';
    const CONFLICT = 'Conflict';
    const NEW = 'New'; 
    const MERGED = 'Merged';
    
         var typesWithMeta = new Object();
     typesWithMeta['ApexClass'] = true;
     typesWithMeta['ApexTrigger'] = true;
     typesWithMeta['ApexComponent'] = true;
     typesWithMeta['ApexPage'] = true;
     typesWithMeta['EmailTemplate'] = true;
//     typesWithMeta['StaticResource'] = true;
//     typesWithMeta['Document'] = true;
    
    
    	var notEditableLi = new Object();
    notEditableLi['Document'] = true;
    notEditableLi['StaticResource'] = true;
    
    
    Visualforce.remoting.timeout = 120000;
    var dataMap = {};
    var Mergewrap;
    var MergeBase64Str =[];
    
    var attList = [];
    
	
	var bundleComponentStack = [];
	var itemType;
	var dataProcessing = false;
	
    
    
    if(typeof jQuery != 'undefined'){
         $j = jQuery.noConflict();
    }
    
    const apiVersion = {!localApiVersion};
    var sessionId = "{!$Api.Session_Id}";
    
    
    function getCalcWidth(isXml)  
	{
	    return (isXml)? document.getElementById('ruler-xml').offsetWidth: document.getElementById('ruler').offsetWidth;
	}
    
    $j('[id$=branchTargetId]').on("change", function(){ //bind() for older jquery version

        getScope().brSelect = $j('[id$=branchTargetId]').val();
        getScope().onChange();
     }); 
    

    function openLookupPopup(branchTargetName,branchTargetId,Name,branchName,srcBranchNameEsc,emptysearch){
    	if (srcBranchNameEsc != undefined && srcBranchNameEsc != ''){
    		srcBranchNameEsc = srcBranchNameEsc.replace(/'/g, "\\'");
    	}
		dlm_openLookupPopup(branchTargetName,branchTargetId,Name,branchName + '!=\'' + srcBranchNameEsc + '\'',emptysearch);    	
    }
    
    function getDate(jsonDate){
    	var backToDate = new Date(jsonDate).toUTCString();
    	return backToDate;
    }
    
    function correctDate(list){
    	for (var i = 0; i< list.length; i++ ){
    		var jsonDate = list[i].changedOn;
    		if (jsonDate != undefined){
    			list[i].changedOn = getDate(jsonDate);
    		}
    		jsonDate = list[i].tgtChangedOn;
    		if (jsonDate != undefined){
    			list[i].tgtChangedOn = getDate(jsonDate);
    		}
    	}
    }
    
    var attempts = 3;
	var max_wait_cycles = 100;
	var inProgress = true;
	var hStatusWrap;

	var srcBranchId;
	var tgtBranchId;
	var branchLastUpdatedDate;
	
	var errors = false;
	


	function setMessageOnPage1(str)
	{
         if($j('#msg') != undefined)
         {
             $j('#msg').remove();
         }
         var parentVal = $j("[id$='msg']");
         if(parentVal != undefined && str!='')
         {
              var childVal = '<span id="msg"><span ><div class="message warningM4" role="alert">'+
               				'<table border="0" cellpadding="0" cellspacing="0" class="messageTable" style="padding:0px;margin:0px;">'+
               				'<tbody><tr valign="top"><td><img alt="warning" class="" src="/s.gif" title="warning"></td>'+
               				'<td class="messageCell"><div id="j_id0:meta:j_id15:j_id16:j_id18" class="messageText"><span>'+str+'</span></div></td></tr>'+
               				'</tbody></table></div></span>'+
               				'</span>';
              parentVal.before(childVal);
         }
	}

	function showErrorMessage(str)
    {
        if($j('#msg') != undefined)
        {
            $j('#msg').remove();
        }
        var parentVal = $j("[id$='msg']");
        if(parentVal != undefined)
        {
            var childVal = '<span id="msg">'+
                            '<span>'+
                                '<div class="message errorM3" role="alert">'+
                                    '<table border="0" cellpadding="0" cellspacing="0" class="messageTable" style="padding:0px;margin:0px;">'+
                                        '<tbody>'+
                                            '<tr valign="top">'+
                                            '<td>'+
                                                '<img alt="ERROR" class="msgIcon" src="/s.gif" title="ERROR">'+
                                            '</td>'+
                                            '<td class="messageCell">'+
                                                '<div class="messageText">'+
                                                    '<span style="color:#cc0000">'+
                                                        '<h4>Error:</h4>'+
                                                    '</span>'+
                                                    str+'<br>'+
                                                '</div>'+
                                            '</td>'+
                                            '</tr>'+
                                            '<tr>'+
                                                '<td></td>'+
                                                '<td></td>'+
                                            '</tr>'+
                                        '</tbody>'+
                                    '</table>'+
                                '</div>'+
                            '</span>'+
                        '</span>';
             parentVal.before(childVal);
        }
        unbindWindow();
    }
        
    function unbindWindow()
    {
        $j(window).unbind();
    }
    
     
    function checkItemAll(ele) {
        var changeClass = ele.getAttribute('styleclass');
        var checkboxes = document.getElementsByClassName(changeClass);
         if (ele.checked) {
             for (var i = 0; i < checkboxes.length; i++) {
                 if (checkboxes[i].type == 'checkbox') {
                     checkboxes[i].checked = true;
                 }
             }
         } else {
             for (var i = 0; i < checkboxes.length; i++) {
                 if (checkboxes[i].type == 'checkbox') {
                     checkboxes[i].checked = false;
                 }
             }
         }
    }
    
    function startZipCreation(error, msg, branchId){
    	if (error > 0){
    		showErrorMessage(msg);
    	}else{// no errors
    		console.log('branchZipCreator starting...');
    		
    		branchZipCreator();
    	}
    }
    
    var SFURI = new Object();
    	SFURI.COLLECT_BKUP_INFO = '{!$RemoteAction.MergeBranchesController.collectBackupInfo}';
	 	SFURI.GET_CHUNK_BLOCKS = '{!$RemoteAction.MergeBranchesController.getChunkBlocks}';
		SFURI.POPULATE_PATCH = '{!$RemoteAction.MergeBranchesController.populatePatch}';
	 	SFURI.SET_AUTH = '{!$RemoteAction.MergeBranchesController.setUpAuthentication}';
	 	SFURI.GET_MERGE_DETAIL = '{!$RemoteAction.MergeBranchesController.getMergeDetail}';
	 	SFURI.GET_ATT = '{!$RemoteAction.MergeBranchesController.getMergeAttachments}';
	 	SFURI.SOURCE_TYPE = 'Branch';
	 	SFURI.SOURCE_NAME = 'Not set';
    
    
    function processZipCreation(errorCode,logId,logAttId,patchListJSON,logsListJSON,validateOnly, sourceName, msg){
    	

		if (errorCode != 0){
			if (msg != undefined && msg.indexOf('Corrupted Repository record') < 0){
				showErrorMessage('First error: ' + msg);
				console.log('error');
		 	}else if (!isEmpty(logAttId)){
		 		composeDeployZip(logAttId);
		 	}else{// wrong settings on repository, then go ahead
    	        console.log('finalCall');// continue as usual
                finalCall();
		 	}
		}else{
	    	if (validateOnly == null || validateOnly == undefined) validateOnly = false;
	    	SFURI.SOURCE_NAME = sourceName;
    		if (!isEmpty(logId) && !isEmpty(logAttId) && logAttId.length == 18 && !isEmpty(patchListJSON) && !isEmpty(logsListJSON)){//prepare backup
 		   			var backUp = new BackUp(logAttId, logId, patchListJSON, logsListJSON, SFURI, sessionId);
		    		patchId = backUp.getPatchId();
    				backUp.createBackUp(validateOnly,function(err){
    					if (err && err.length > 0){
    						showErrorMessage(err[0]);
	    				}else{
    						composeDeployZip(logAttId);
    					}
	    			})
    		}else{// go ahead
            	console.log('nothing to merge');// continue as usual
            	finalCall();
    		}
    	}
    }
    
    var MergeBase64Li = [];
    
    function composeDeployZip(logAttachmentId)
    {
    	console.log('composeDeployZip');
    	var deployZip = new DeployZip(logAttachmentId, SFURI);
    	deployZip.create(true, function(err){
    		if (err && err.length > 0){
    			showMessage(err[0]);
    		}else{// no errors
    			MergeBase64Li = deployZip.getMergeList();
    			if (MergeBase64Li.length > 0){
    				saveAttachment();
    			}else{
    				 finalCall();
    			}
    		}
    	})
    }
    
    
    function saveAttachment()
    {
        if(MergeBase64Li.length > 0)
        {
            var str = MergeBase64Li[0];
            insertMergeAttachment(str,patchId);
            MergeBase64Li.shift();
        }
        
    }
    
    function handleMergeDml()
    {
        if(MergeBase64Li.length > 0)
        {
            saveAttachment();
        }
        else
        {
            finalCall();
        }
    }
    
    
    /** 		call every time when combo box updated			**/
    function reLoad(){
    	////////console.log('reloading...');
    	getScope().initLoad();
    }
    
    function refreshStatus(batchJobId){
    	Visualforce.remoting.Manager.invokeAction(
            '{!$RemoteAction.MergeBranchesController.getApexJobStatus}',
            	batchJobId,	
                function(r, e)
                {
                    if(e.status) 
                    {
                    	if (r == undefined || r == null) return;// no active jobs - all completed or aborted
                    	setMessageOnPage('Merge branches job status: ' + r);
                        if(r !== 'Completed' && r !== 'Aborted' && r !== 'Failed' ){// end of wait cycle, change message and exit
							setTimeout(function(){ refreshStatus(batchJobId) }, 5000);
                        }else if (r === 'Completed'){// job complete - goto target merged branch
                        	complete();
                        }
                    }
                    else
                    {
                        showErrorMessage(e.message);
                    }
         });
    }
    

    /******				start the apex part of merging functionality		******/
    
    function mergeBranches(){
    	var brId = $j('[id$=branchTargetId]').val();
    	//verify is conflicts
    	var isConflicts = false;
//    	var filledName = encodeURIComponent(getScope().branchNewTargetName);
    	var filledName = getScope().branchNewTargetName;
    	var srcName = document.getElementById('pg:allCompForm:FirstPageBlock:branchblock:pbs2:bsi2:srcBranch').value;
    	var selectedBranch = {}
    	
    	if (srcName === filledName){
    		errors = true;
    		showErrorMessage('Branch with such name already exists');
    		return;
    	}else if ((filledName == undefined || filledName == '') && (brId == null || brId == undefined || brId == '')){
    		errors = true;
    		showErrorMessage('Select branch for  merge');
    		return;
    	}
    	commit();
    }
    
    function processResults(data){
			//console.log('uploadResult='+data);
           	getScope().processUploadResults(data);
	}
    
    
    
    /******				update data before commit						******/
    
    function commit(){
    	getScope().commit();
    }
    
    /****** 			angularJs modules description				******/
    
        var myApp = angular.module("mergeCommit", ['base64','ngMaterial', 'ngMessages', 'material.svgAssetsCache','angularModalService','ngAnimate']);
    
        // this variable holds the difference object
        var diff3 = {};
        
	    function clearMessage(){
    		console.log('clearMessage');
	        if($j('#msg') != undefined){
	             $j('#msg').remove();
    	    }
    	}
    	
    	var changedValues = {};
		var uid = 0;
		var directCopy = false;

		function initStack(){
			changedValues = {};
			uid = 0;
		}

		// if bFirst = true, add 2 stack
		// else update
		function add2stack(obj, bFirst){
			if (bFirst){
				changedValues[uid] = obj;
				uid++;
				return (uid-1);
			}
			var id = obj.id;
			if (id != undefined)
				changedValues[id] = obj;
			return id;
		}

        
		function updateCRC32(Item,newCRC32){
			if (typesWithMeta[Item.compType]){// detect which part is edited, and update only this
				if (Item.crc32 != undefined && Item.crc32 != ''){
					var crcArray = Item.crc32.split(' ');
					if (crcArray.length == 2){
						if (Item.compType.indexOf('(meta)') > -1){// update only 2nd part
							Item.crc32 =  crcArray[0] + ' ' + newCRC32;
						}else{
							Item.crc32 = newCRC32 + ' ' + crcArray[1];
						}
						return;
					}
				}
				Item.crc32 = newCRC32;
			}else{
				Item.crc32 = newCRC32;
			}
		}
		
		
		// analyse and return bundle's crc32 sum (see the specs for detail)
		function composeBundleCrc(componentStack){
			var mapComp = {'.cmp':'', '.cmp-meta.xml':'' ,'Controller.js':'','Helper.js':'','.css':'','.auradoc':'','Renderer.js':'','.design':'','.svg':''};
            var crcCode = '';
                                                                
			for (var i = 0; i < componentStack.length; i++){
                 var zipFileName = componentStack[i].compName;
                 if(zipFileName != undefined)
                 {
          			var index = getBundleExt(zipFileName);
                    if (index > -1){
        	          	var ext = zipFileName.substr(index)
    	                mapComp[ext] = componentStack[i].crc32;
	                    //debug('unzipped:'+zipFileName);
                    }
                 }
             }
             crcCode = mapComp['.cmp']+','+mapComp['.cmp-meta.xml']+','+mapComp['Controller.js']+','+mapComp['Helper.js']+
                                      ','+mapComp['.css']+','+mapComp['.auradoc']+','+mapComp['Renderer.js']+','+mapComp['.design']+','+mapComp['.svg'];
             //debug('crc:'+crcCode);
             return crcCode;
		}
		
		function getBundleExt(str){
        	var index = str.lastIndexOf('.js');
        	if (index > -1){// verify 3 exts
        		index = str.lastIndexOf('Controller.js');
        		if (index == -1){
	        		index = str.lastIndexOf('Helper.js');
			   		if (index == -1){
	        			index = str.lastIndexOf('Renderer.js');
       				}
        		}
        		return index;
        	}
        	index = str.lastIndexOf('.cmp-meta.xml');
        	if (index == -1){
        		return str.lastIndexOf('.');
        	}
        	return index;
        }
        
        var Page = function(obj){
             	////console.log('creating a page')
            	this.staticLimit = 20;
                this.orderByColumn = 'compName';
            	this.isReverse = false;
            	this.metaOffSet = 0;
            	this.totalRecords = 0;
            	this.viewLimit = this.staticLimit;
        		if (obj != undefined){
        			if (obj.OrderByColumn != undefined){ this.orderByColumn = obj.OrderByColumn;}
        			if (obj.isReverse != undefined){ this.isReverse = obj.isReverse;}
        			if (obj.metaOffSet != undefined){ this.metaOffSet = obj.metaOffSet;}
        			if (obj.totalRecords != undefined){ this.totalRecords = obj.totalRecords;}
        			if (obj.viewLimit != undefined){ this.viewLimit = obj.viewLimit;}
        		}
		}
		    
        Page.prototype.refreshOrderBy = function(orderVal) {
                this.metaOffSet = 0;
                this.viewLimit = this.metaOffSet + this.staticLimit;
                if(orderVal === this.orderByColumn)
                    this.isReverse = !this.isReverse;
                else
                {
                    this.isReverse = false;
                    this.orderByColumn = orderVal;
                }
        };
        Page.prototype.showFirst = function() {
                this.metaOffSet = 0;
                this.viewLimit = this.staticLimit;
        };
        Page.prototype.listPrevious = function() {
                this.metaOffSet = this.metaOffSet - this.staticLimit;
                if(this.metaOffSet < 0)
                    this.metaOffSet = 0;
                this.viewLimit = this.metaOffSet + this.staticLimit;
        };
        Page.prototype.listNext = function(tempTotal) {
                if((this.metaOffSet + this.staticLimit) < tempTotal)
                {
                    this.metaOffSet = this.metaOffSet + this.staticLimit;
                    this.viewLimit = this.metaOffSet + this.staticLimit;
                }
        };
        Page.prototype.showLast = function(tempTotal) {
                this.metaOffSet = tempTotal - (tempTotal % this.staticLimit);
                if(this.metaOffSet == tempTotal && this.metaOffSet != 0)
                {
                    this.metaOffSet = tempTotal - this.staticLimit;
                }
                this.viewLimit = this.metaOffSet + this.staticLimit;
        };
        Page.prototype.isPrevious = function() {
                if(this.metaOffSet < 1) 
                    return true;
                else {
                    return false;
                }
        };
        Page.prototype.isNext = function(tempTotal){
                if(tempTotal > this.metaOffSet+this.staticLimit){
                    return false;
                }
                else {
                    return true;
                }
        };
        Page.prototype.totalPageCount = function(tempTotal){
                var totalPage = parseInt(tempTotal % this.staticLimit > 0 ? (tempTotal / this.staticLimit)+1 : (tempTotal / this.staticLimit));
                return totalPage;
                
        };
        Page.prototype.currentPageNo = function(tempTotal){
                var currentPage = 1;
                if(this.metaOffSet <  this.staticLimit)
                    currentPage =  1;
                else
                {
                    currentPage = Math.ceil(this.metaOffSet / this.staticLimit)+1;
                }
                return currentPage;
        };
 
        
		
	
  		myApp.service('dataManager', function($q) {
            return {
                getData : function(block,tgtBranchId) {// 
                    var deferred = $q.defer();
                    
                    Visualforce.remoting.Manager.invokeAction(
                        '{!$RemoteAction.MergeBranchesController.getAllData}',
                        JSON.stringify(block),
                        tgtBranchId,
                        function(result, event) {
                            if (event.status) {
                                deferred.resolve(result);
                            }
                            else {
                                deferred.reject(event);
                            }
                        });
                    return deferred.promise;
                },
                getAllBranchData : function() {
                    var deferred = $q.defer();
                    
                    branchId ='{!srcBranchId}';
                    
                    Visualforce.remoting.Manager.invokeAction(
                        '{!$RemoteAction.MergeBranchesController.getAllBranchData}',
                        branchId,
                        function(result, event) {
                            if (event.status) {
                                deferred.resolve(result);
                            }
                            else {
                                deferred.reject(event);
                            }
                        });
                    return deferred.promise;
                },
                getAttachments : function(compAttId, repCompAttId) {
                    var deferred = $q.defer();
                    Visualforce.remoting.Manager.invokeAction(
                        '{!$RemoteAction.MergeBranchesController.getAttachmentPair}',
                        compAttId,
                        repCompAttId,
                        function(result, event) {
                            if (event.status) {
                                deferred.resolve(result);
                            }
                            else {
                                deferred.reject(event);
                            }
                        });
                    return deferred.promise;
                },
                updateSet : function(jsonList) {
                    var deferred = $q.defer();
                    var srcBranchId = '{!srcBranchId}';
                    var mergeSetName = '{!mergeSetName}';
                    if (mergeSetName == undefined || mergeSetName == '') mergeSetName = 'MERGEBRANCHSET';
                    
                    Visualforce.remoting.Manager.invokeAction(
                        '{!$RemoteAction.MergeBranchesController.updateSet}',
                        mergeSetName,
                        srcBranchId,
                        jsonList,
                        function(result, event) {
                            if (event.status) {
                                deferred.resolve(result);
                            }
                            else {
                                deferred.reject(event);
                            }
                        });
                    return deferred.promise;
                },
                getCached : function(attId) {
                    var deferred = $q.defer();
                    Visualforce.remoting.Manager.invokeAction(
                        '{!$RemoteAction.MergeBranchesController.getCached}',
                        attId,
                        function(result, event) {
                            if (event.status) {
                                deferred.resolve(result);
                            }
                            else {
                                deferred.reject(event);
                            }
                        });
                    return deferred.promise;
                }
                
            }
        });
  		
  		var isUploadSuccess = true;
  		var uploadError;
  
        myApp.$inject = ['$scope', '$filter','$controller','CacheService','ModalService', 'ShareService', 'ArchiveService'];
        
        myApp.factory('ShareService', function(){
			var _x = {};

			return {
    			getX: function () {
        		return _x;
    		},
    			setX: function (value) {
        		_x = value;
    			}
			};
		});
        
        
        myApp.controller('CustomController', ['$scope',  'close','ShareService', function($scope, close, ShareService) {
         
        	$scope.question = {
    			selected: 1,
    			choices:[{
            				id: 1,
            				text: "Replace component in target branch with component from  source branch"
        				},{
            				id: 2,
            				text: "Leave component in target branch untouched"
        				}]
        	};
         	$scope.replace1 = ShareService; 
        	var params =  $scope.replace1.getX();
        	if (params != undefined){
        		$scope.question.selected = params.selected == undefined ? 1 :params.selected;
        		$scope.alwaysDo = params.alwaysDo;
        	}else{
        		$scope.question.selected = 1;
        		$scope.alwaysDo = false;
        	}
         	
 			$scope.close = function(result) {
 				var choice;
 				if (result){//apply clicked
 					choice = $scope.question.selected;
 				}else{// no choice
					choice = 0;
 				}
 				$scope.replace1.setX({selected : choice, alwaysDo: $scope.alwaysDo});
			 	close(choice, 150); // close, but give 500ms for bootstrap to animate
 			};

		}]);
        

        var app = myApp.controller("MergeBranchesControllerAJS", function($scope, $base64, $controller, dataManager, CacheService,  ModalService, ShareService, ArchiveService, $filter,  $interval, $timeout, filterFilter) {
        
        	angular.extend(this, $controller('CustomController', {
         		$scope: $scope,
         		close: close
     		}));
     		
     		$scope.AlgorithmSet = [{'id':'1','name':'Default'},{'id':'2','name':'Alternative'}];
     		$scope.selectedAlg = '1';
     		$scope.branchNewTargetName = '';

        	$scope.replace2 = ShareService;
        	
			$scope.isLoading = false;
			$scope.AllowMergeForComponents = true;
			$scope.mergeButton = false;
			
            $scope.componentList = []; // type ConflictWrapper
            $scope.newCompList = []; // type SafeCommitCompWrapper
            $scope.notMergeCompList = []; // type NotCommitCompWrapper
            $scope.bundleList = [];
            
            // list of pointers to first 2 aforementioned arrays
            $scope.newCompListPtr = [];
            $scope.componentListPtr = [];
            
            $scope.componentListShow = true;
            $scope.newCompListShow = true;
            $scope.notMergeCompListShow = true;
            
            
            $scope.enableTables = false;
            $scope.CommitStep = 0;
            $scope.EditBundle = false;
            $scope.EditMode = false;
            
            $scope.disableNextPrevious = false;
            
            var tempObj1 = {};
            tempObj1['compName'] = 'Component Name';
            tempObj1['compType'] = 'Component Type';
            tempObj1['changedBy'] = 'Changed By';
            tempObj1['changedOn'] = 'Changed On';
            $scope.fieldSet1 = tempObj1;
            
            var tempObj2 = {};
            tempObj2['compName'] = 'Component Name';
            tempObj2['compType'] = 'Component Type';
            tempObj2['changedBy'] = 'Changed By';
            tempObj2['changedOn'] = 'Changed On';
            $scope.fieldSet2 = tempObj2;
            
            
            /*********************************************/


            $scope.IsErrorNotBS = false;
            $scope.groupedItems = [];
            $scope.itemsPerPage = 20;
            $scope.pagedItems = [];
            $scope.currentPage = 0;


			$scope.selectionConflict = [];
			$scope.isAllChecked1 = false;
			$scope.selectionNew = [];
			$scope.isAllChecked2 = false;
            $scope.bIgnoreLocal = false;
			$scope.dataProcessing = false;
			
			$scope.loading = false;
			$scope.brSelect == '';
			$scope.targetBranchName;
			$scope.sourceBranchName;
			$scope.targetDetails;
			$scope.sourceDetails;
			$scope.targetDetailsBundle;
			$scope.sourceDetailsBundle;
			$scope.alwaysDo = false;
			
			$scope.bOverwriteAll = false;
			$scope.disableAllUI = false;
			$scope.onlyExistingBranches = false;
			
			$scope.overallChanges = function() {
               	for (var x = 0; x < $scope.componentListPtr.length; x++){
               		var rec =  $scope.componentListPtr[x];
               		if ($scope.bOverwriteAll){
               			if (rec.isConflict){
               				rec.bkUp4Conflict = rec.isConflict;//save old value
               				rec.isConflict = false;
               				rec.isAutoResolved = true;
               				rec.compare = AUTORESOLVED;
               			}
               		}else{
               			if (rec.bkUp4Conflict != undefined){
               				rec.isConflict = rec.bkUp4Conflict;
               				rec.isAutoResolved = !rec.isConflict;
               				rec.bkUp4Conflict = undefined;
               				rec.compare = CONFLICT;
               			}
               		}
               	}
            }
			
			$scope.updatePages = function() {
				$scope.safe = new Page({orderByColumn:'changedOn',isReverse : true});
    	        $scope.notCommit = new Page({orderByColumn:'compName', isReverse : true});
    	    }
			
			$scope.showHideComponentList = function(){
			    $timeout(function() {
                       $scope.componentListShow = ($scope.componentListShow)? false:true;
                });
			}

			$scope.showHideNewCompList = function(){
			    $timeout(function() {
                       $scope.newCompListShow = ($scope.newCompListShow)? false:true;
                });
			}

			$scope.showHidenotMergeCompList = function(){
			    $timeout(function() {
                       $scope.notMergeCompListShow = ($scope.notMergeCompListShow)? false:true;
                });
			}
			
			$scope.verify = function(name){
				
				//console.log(name +' aganst '+JSON.stringify($scope.allBranches));
				if ($scope.allBranches != undefined && $scope.allBranches.length > 0){
					for (var x = 0; x< $scope.allBranches.length; x++){
						if ($scope.allBranches[x].branchName === name){
							return false;
						}
					}
				}
				return true;
			}
	
			function getMetaCRC(crcA){
				if (crcA == undefined || crcA == '') return -1;
				var i =  crcA.indexOf(' ');
				if ( i > -1){
					return crcA.substr(i);
				}
				return -1;
			}

			function getMainCRC(crcA){
				if (crcA == undefined || crcA == '') return -1;
				var i =  crcA.indexOf(' ');
				if ( i > -1){
					return crcA.substr(0,i);
				}
				return -1;
			}
			
			function splitPairs(componentList){
				var newList = [];
				if (componentList != undefined && componentList.length > 0){
					for (var x = 0; x < componentList.length; x ++){
						var rec = componentList[x];
						if (typesWithMeta[rec.compType]){// verify is meta equals, if true, do NOT add it
							if (CONSIDER_META){
								if (getMetaCRC(rec.crc32) !== getMetaCRC(rec.crc32C)){
									var newRec = JSON.parse(JSON.stringify(rec));// clone a record
									newRec.fileName += '-meta.xml' 
									newRec.compType += '(meta)';
									newRec.isMeta = true;// to detect that is meta - they must not be rendered
									newRec.compId += '1'; // add 1 digit to Id, remove it when making operations with SF
									rec.meta =  newRec;// add pointer to meta extension
									newList.push(newRec);
								}
								rec.compId += '0';
								if (getMainCRC(rec.crc32) !== getMainCRC(rec.crc32C)){// add main component only if they are different
									newList.push(rec);
								}else{
									rec.hidden = true;
									newList.push(rec);
								}
							}else{
								rec.compId += '0';
								if (getMainCRC(rec.crc32) === getMainCRC(rec.crc32C) && getMetaCRC(rec.crc32) !== getMetaCRC(rec.crc32C)){// correct flags only in 1 case
									rec.isConflict = false;
									rec.isAutoResolved = true;
		               				rec.compare = AUTORESOLVED;
								}
								newList.push(rec);
							}
						}else{
							rec.compId += '0';
							newList.push(rec);
						}
					}
				}
				return newList;
			}
	
			
			var left_to_resolve = 0;
			$scope.loadData = function(brId,callback){
				left_to_resolve = 0;
				dataManager.getAllBranchData().then(
                    function (data) {
                    	if (brId == undefined){
                    		showErrorMessage('Target branch does not exist or not specified');
                    		callback();
                    	}else if (data != undefined){
                    		$scope.componentList = [];
                    		$scope.newCompList = [];
                    		$scope.notMergeCompList = [];
                   			left_to_resolve ++;
                   			$scope.loadBlockofData(data, brId,  function(){callback();});
        	            	if  (left_to_resolve == 0){
        	            		callback();
        	            	}  
                    	}else{
                    		callback();
                    	}
                    },
                    function (error) {
            			$j('#spinner').css('display','none');
            			$scope.loading = false;
            			$scope.isLoading = false;
            			$scope.enableTables = false;
                    }
				);
			}
			
			$scope.loadBlockofData = function(IdBlockList,tgtbranch,callback){
				if (IdBlockList.length > 0){
					var block = IdBlockList.shift();
					dataManager.getData(block,tgtbranch).then(
    	                function (data) {
    	                  if (data != null && data != undefined){
								$scope.componentList = add($scope.componentList,data.conflictsList);
								$scope.newCompList = add($scope.newCompList,data.newList);
								$scope.notMergeCompList = add($scope.notMergeCompList,data.notCommitList);
    	                  }	
  			              $timeout(function() {
	                    		$scope.loadBlockofData(IdBlockList,tgtbranch,callback);
	               		  });
        	            },
            	        function (error) {
            				$j('#spinner').css('display','none');
            				$scope.loading = false;
            				$scope.isLoading = false;
                    	}
					);
				}else{
					joinThreads(callback);
				}
				
				function add(base,part){
					if (part != undefined && part.length > 0){
						return base.concat(part);
					}
					return base;
				}
			}
			
			// Joining threads, meaning that the callback only will
    		// be performed when ALL parallel threads have executed
    		function joinThreads(callback) {
        		left_to_resolve--;
				////console.log('joinThreads,'+left_to_resolve);

		        if ((left_to_resolve == 0) && (callback !== null)) {
        		    callback();
        		}
    		}
    		
    		$scope.finalLoad = function(){
                    		$scope.componentListPtr = [];
	            			$scope.componentList = splitPairs($scope.componentList);
	            			////console.log(JSON.stringify($scope.componentList));
	            			correctDate($scope.componentList);
	            			correctDate($scope.newCompList);
	            			correctDate($scope.notMergeCompList);
	            			// generate the tables of pointers - component from componentList always will be in 1st  table 
	            			for (var x = 0; x < $scope.componentList.length; x++){
	            				var comp = 	$scope.componentList[x];
	            				if (comp.isAutoResolved){
	            					comp.compare = AUTORESOLVED;
	            				}else if (comp.isConflict){
	            					comp.compare = CONFLICT;
	            				}
            					$scope.componentListPtr.push(comp);
	            			}
	            			// add all new components
	            			for (var x = 0; x < $scope.newCompList.length; x++){
	            				var comp = 	$scope.newCompList[x];
	            				comp.compare = NEW;
            					$scope.componentListPtr.push(comp);
	            			}
	                    	//debug('retrieve data:'+JSON.stringify($scope.componentListPtr));
	            			$j('#spinner').css('display','none');
            				$scope.isLoading = false;
	            			$scope.loading = false;
	            			$scope.enableTables = true;
							////console.log('finalLoad');
			}
    		
			
			
		// this function load raw data tied with specific component, then add it to  components stack
		$scope.loadComponent = function(item){
			if (item != undefined && item.repCompAttId != undefined  && item.compAttId != undefined){
				dataManager.getAttachments(item.compAttId,item.repCompAttId).then(
					function (data) {
						if (data != undefined && data.length == 2){// extract files from zip
							var zipStr0 = data[0];
							var zipStr1 = data[1];
                            //debug('Zip file length0-'+(zipStr0.base64.length/(1024*1024))+' MB');
                            //debug('Zip file length1-'+(zipStr1.base64.length/(1024*1024))+' MB');
                            if (item.compType == 'AuraDefinitionBundle'){
								ArchiveService.addZips(zipStr0,zipStr1,item);
								$scope.openPopUpInfo(item);
                            }else{
								ArchiveService.addZips(zipStr0,zipStr1,item);
								$scope.getMergeInfo(item);
							}
						}
					},
					function (error) {
					}
				);
			}
		}
		
		$scope.uploadIdSet = function(mList,newBranch){
			var newList  = [];
			if (mList != undefined && mList.length > 0){// remove last digit from id
				for (var x = 0; x < mList.length; x++){
					newList.push(mList[x].slice(0,18));
				}
			}
			$scope.disableMergeButton();

			dataManager.updateSet(JSON.stringify(newList)).then(
				function (data) {
					if (data != undefined && data){// extract files from zip
						isUploadSuccess = true;
						//debug('updateSet - success, next addToBranch');
						if (newBranch == undefined){
							$scope.updateMergedData();
						}else{
							addToBranch(newBranch);
						}
					}else{
						isUploadSuccess = false;
		           		showErrorMessage('update fails');
						$scope.enableMergeButton(); 
					}
				},
				function (error) {
					isUploadSuccess = false;
	           		showErrorMessage(error);
					$scope.enableMergeButton(); 
				}
			);
		}
		
		
		$scope.processUploadResults = function(uploadResult){
					//console.log('uploadResult='+uploadResult);
					if (uploadResult === 0 || uploadResult === '0'){// extract files from zip
						isUploadSuccess = true;
						if ($scope.complete){
							$scope.finalize();
						}else{//continue upload
							$scope.chainUpload();
						}
					}else{
						isUploadSuccess = false;
						showErrorMessage('update fails');
					}
		}
		
		
		
		$scope.finalize = function(){
							console.log('update was successful');
							$scope.enableTables = false;//set 'need update' flag to false === disable the further edit of components 
							$scope.disableMergeButton(); 
							console.log('call addToBranch with '+$scope.branchNewTargetName);
							addToBranch($scope.branchNewTargetName);
							
							
//							finalCall();
							
		}
		
		$scope.chainUpload = function(){
			var attTotalSize = 0;
			var mergeList = [];

			while($scope.index < $scope.selectionConflict.length){
				var conflictComp = $scope.allCompMap[$scope.selectionConflict[$scope.index]];// get info about component
				//debug(JSON.stringify(conflictComp));
				if (conflictComp != undefined && conflictComp.compType != 'AuraDefinitionBundle'){
					if (conflictComp.replace != undefined && conflictComp.replace == 1){
					// replace compAttId => repCompAttId
					// no need in attachment updating 
					}else{
						var attDescriptor = ArchiveService.getZipDescription($scope.selectionConflict[$scope.index]); // get info about attachment
						//debug(JSON.stringify(attDescriptor));
						// form list of MergeWrapper
						if (attDescriptor != undefined){
							var mergeItem = {};
							if (attTotalSize + attDescriptor.length > 2500000){
								uploadAttachments(JSON.stringify(mergeList));
								return;
							}
							attTotalSize += attDescriptor.length;
							mergeItem.compId = conflictComp.compId.slice(0,18);
							mergeItem.lastCompHistoryId = conflictComp.lastCompHistoryId;
							if (conflictComp.isAutoResolved && attDescriptor.crc32 == undefined){
								mergeItem.crc32 = conflictComp.crc32;
								//debug('null replaced with:'+mergeItem.crc32);
							}else{
								mergeItem.crc32 = attDescriptor.crc32;
							}
							mergeItem.attId = attDescriptor.compAttId;
							mergeItem.base64 = ArchiveService.getZip(attDescriptor.compAttId);
							mergeList.push(mergeItem);
						}
					}
				}else if (conflictComp != undefined && ArchiveService.getLength(conflictComp.compAttId) !== 0){
					//debug(JSON.stringify(conflictComp));
					var mergeItem = {};
					if (attTotalSize +  ArchiveService.getLength(conflictComp.compAttId) > 2500000){
						uploadAttachments(JSON.stringify(mergeList));
						return;
					}
					attTotalSize += ArchiveService.getLength(conflictComp.compAttId);
					mergeItem.compId = conflictComp.compId.slice(0,18);
					mergeItem.lastCompHistoryId = conflictComp.lastCompHistoryId;
					mergeItem.crc32 = conflictComp.crc32;
					mergeItem.attId = conflictComp.compAttId;
					mergeItem.base64 = ArchiveService.getZip(conflictComp.compAttId);
					mergeList.push(mergeItem);
				}
				$scope.index++;
			}
			$scope.complete = true;
			if (mergeList.length > 0){
				uploadAttachments(JSON.stringify(mergeList));
			}else{
				$scope.finalize();
			}
		}
		
		$scope.updateMergedData = function(){
				setMessageOnPage('Updating Data... Please Wait');
				$scope.disableMergeButton(); 
				//debug('selectionConflict.length'+$scope.selectionConflict.length);
				if ($scope.selectionConflict.length > 0){
					$scope.index = 0;
					$scope.complete = false;
					$scope.chainUpload();
					return;
				}
				//debug('no selected with conflicts, but may exists a new components');
				$scope.enableTables = false;//set 'need update' flag to false === disable the further edit of components 
//				$scope.disableMergeButton();
				$scope.finalize(); 
//				setMessageOnPage('Complete');
		}
		
		// commit functionality
		$scope.commit = function(){
			// reset errors flag
			errors = false;
			// clear messages
			clearMessage();
			if (!$scope.enableTables){ //completion commit (usually after errors)
				console.log('call addToBranch with '+$scope.branchNewTargetName);
				addToBranch($scope.branchNewTargetName);
				return;
			}
			if (!$scope.getStatusConflicts()){// all conflicts resolved
				// collect items to commit
				//debug(JSON.stringify($scope.selectionConflict));
				//debug(JSON.stringify($scope.selectionNew));
				if (($scope.selectionConflict.length + $scope.selectionNew.length) == 0){
					showErrorMessage('Select at least one component');
					errors = true;
					return;
				}
				$scope.allCompMap = {};
					for(var l = 0; l < $scope.componentList.length; l++){
						$scope.allCompMap[$scope.componentList[l].compId] = $scope.componentList[l];
					}
					// update attachments and components history
					// choose only components that were changed
					var newConflictList = [];
					for (var x = 0; x < $scope.selectionConflict.length; x++){
						var conflictComp = $scope.allCompMap[$scope.selectionConflict[x]];
						if (conflictComp.replace != 0  && conflictComp.replace != 2){// == 1 or undefined
							newConflictList.push($scope.selectionConflict[x]);
						}
					}
					$scope.selectionConflict = newConflictList;
					//debug(JSON.stringify($scope.allCompMap));
					//debug(JSON.stringify($scope.selectionConflict));
				var allSelected = newConflictList.concat($scope.selectionNew);
				
				
				//debug('allSelected:'+allSelected.length);
				if (allSelected.length > 0){
					isUploadSuccess = false;
					$scope.uploadIdSet(allSelected);
				}else{
					$scope.enableTables = false;//set 'need update' flag to false === disable the further edit of components 
					$scope.disableMergeButton(); 
					setMessageOnPage('Complete');
				}
			}else{
           		showErrorMessage('Resolve conflicts for selected components OR exclude them from merge');
           		errors = true;
			}
		}
			
			
			
			/******				PopUp methods			******/

 			// edit aura bundle component
            $scope.openPopUpInfo = function(param) {

        	    if  (!ArchiveService.inStack(param.compId)){
            		$scope.loadComponent(param);
			        $scope.loading = true;
			        return;
				}

                $scope.PopUpInfo = {};
                $scope.PopUpInfo.bundleTitle = param.compName;
                $scope.PopUpInfo.compName = param.compName;
                $scope.PopUpInfo.compType = param.compType;
                $scope.targetDetailsBundle = 'changed by'+ formatDetail(param.lastModifiedByName) + ' on'+formatDetail(param.changedOnLocal);
                $scope.sourceDetailsBundle = 'changed by'+ formatDetail(param.localChangedBy) + ' on'+formatDetail(param.localChangedOn);
                $scope.PopUpInfo.Info = param;
                
                // create a backup of zip with aura bundle before work - when the cancel btn will be clicked, zip file left untouched
                if (ArchiveService.inStack(param.compId)){
                	CacheService.push('BACKUP'+ param.compId,ArchiveService.getZipDescription(param.compId)[1]);
                }
                
                
               if (CacheService.isCached(param.compId)){
					CacheService.pop(param.compId, function(data){
						$scope.bundleList = data.bundleList;
						bundleComponentStack = data.bundleComponentStack;
					});
				}else{//not possible to restore from cache
                $scope.bundleList = [];
                var bundles =  ArchiveService.getZipDescription(param.compId);
                var srcMap = bundles[0];
                var tgtMap = bundles[1];
                var index = 0; // counter which is = uid in bundleComponentStack 
 				bundleComponentStack = [];
 				// form bundleComponentStack from retrieved data with UID = index of bundle elements, use this UID for access a descriptor
                for (var key in srcMap) {
               		if (srcMap.hasOwnProperty(key)) {
		                var row = {};
		                var srcDescriptor, tgtDescriptor = null,descriptor;
		                //establish the descriptor
	    	            	row.srcCompName = key;
	    	            	srcDescriptor = srcMap[key];
	    	            	descriptor = srcDescriptor;
	            	    if (tgtMap.hasOwnProperty(key)) {
	                		row.tgtCompName = key;
	    	            	tgtDescriptor = tgtMap[key];
	    	            	if (descriptor != undefined){
	    	            		descriptor.target = tgtDescriptor.target;//update target file if pair (the only difference)
	    	            	}else{
		    	            	descriptor = tgtDescriptor;//never executed
	    	            	}
		                }
                		descriptor.isManualMerge = false;
		                //establish the record
		                row.uid = index;
		                row.compId = param.compId;
		                row.compAttId = param.compAttId;
		                row.fileName = descriptor.fileName
		                row.compName = key;
		                row.compType = param.compType;
                		row.conflictCode = 1;// 0 - equals, 1 - conflict, 2 - merged, 3 - new, 4 -deleted
                		row.isConflict = true;
		                if (srcDescriptor != undefined && tgtDescriptor != undefined){// part of Aura with name compName exists in both containers
		                	if (srcDescriptor.source === tgtDescriptor.target){//they are equals
		                		row.conflictCode = 0;
		                		row.isConflict = false;
		                		descriptor.isManualMerge = true;
		                	}
		                }else if (srcDescriptor != undefined && tgtDescriptor == undefined){// deleted part of Aura
		                	row.conflictCode = 4;
		                	row.isConflict = false;
		                	row.moved = false;
		                }// left code = 1, if no block execs
		                if (descriptor != undefined){
		    	            $scope.bundleList.push(row);
		    	            bundleComponentStack.push(descriptor);
		    	            index++;// index plays role of UID
		                } 
	                }
                }
 
                for (var key in tgtMap) {// add keys which are not present in srcMap
                 if (tgtMap.hasOwnProperty(key)) {
		                var row = {};
		                var descriptor;
		                if (!srcMap.hasOwnProperty(key)) {
	
		                	descriptor = tgtMap[key];
	                		descriptor.isManualMerge = false;
							descriptor.source = '';
							
	    	             	row.tgtCompName = key;
			                row.uid = index;
			                row.compId = param.compId;
			                row.compAttId = param.compAttId;
		    	            row.fileName = descriptor.fileName
		        	        row.compName = key;
		            	    row.compType = param.compType;
	        	         	row.conflictCode = 3;
	                		row.isConflict = false;
		                	row.moved = false;
		        	        if (descriptor != undefined){
		    		            $scope.bundleList.push(row);
			    	            bundleComponentStack.push(descriptor);
			    	            index++;// index plays role of UID
			                } 
	                	}
	                }
				}
				}
				delete bundles;
				//debug(JSON.stringify($scope.bundleList));
				
				
				
				$scope.PopUpInfo.closeBundleManualMerge = function() {
 					var backUpKey = 'BACKUP'+ param.compId;
					if (CacheService.isCached(backUpKey)){
						CacheService.pop(backUpKey, function(data){
							ArchiveService.updateTargetZip(param.compId, data);
						});
					}
                   	$scope.EditBundle = false;
                    $scope.CommitStep = 0;

                    delete $scope.PopUpInfo;
                }
                
                $scope.PopUpInfo.bundleManualMerge = function() {// update original component - ( param)
					//debug(JSON.stringify(bundleComponentStack));
					// verify IsManualMerge flags for all  bundle Components
					if ($scope.bundleList != undefined){
						for (var i = 0; i < $scope.bundleList.length; i++){
							if ($scope.bundleList[i].isConflict){
								//set error message
								$j('.bundle_error_msg').fadeIn().delay(5000).fadeOut();
								return;
							}
						}
						//pass
					}	
					// update archive with data from records with moved = true flag
					for (var i = 0; i < $scope.bundleList.length; i++){
						var bundleComponent = $scope.bundleList[i];
						if (bundleComponent.moved){
							if (bundleComponent.conflictCode == 3  && bundleComponent.moved){//remove comp with uid = i, set MergedFile to null in order to trigger deletion
								ArchiveService.setMergeFile(i, '');
							}else{
								ArchiveService.setMergeFile(i, bundleComponentStack[i].target);
							}
							if (bundleComponent.conflictCode == 4  && bundleComponent.moved){//add comp with uid = i, set MergedFile to src
								ArchiveService.setMergeFile(i, bundleComponentStack[i].source);
							}else{
								ArchiveService.setMergeFile(i, '');
							}
						}
					}
					// set the composite crc32 sum 
					param.crc32 = composeBundleCrc(bundleComponentStack);
					param.isConflict = false;
					param.compare = MERGED;
                   	$scope.EditBundle = false;
                    $scope.CommitStep = 0;
                    var archive = {};
                    archive.bundleComponentStack = bundleComponentStack;
                    archive.bundleList = $scope.bundleList
                    CacheService.push(param.compId,archive);
                    
                    delete $scope.PopUpInfo;
                }
				
                clearMessage();
                $scope.CommitStep = 4;
                $scope.EditBundle = true;
            }
            
            function setParameter(list, value){
	       		for (var x  = 0 ; x < list.length; x ++){
	       			var rec =  list[x];
	       			if (rec != undefined && notEditableLi[rec.metaType] != undefined && rec.isConflict){
    						rec.isConflict = false;
                   			rec.isManualMerge = true;
                   			rec.replace = value;
                   			rec.compare = RESOLVED;
	       			}
	       		}
	        }
            
            function formatDetail(data){
            	if (data == undefined || data == ''){
            		return ' N/A';
            	}
            	return ' '+data;
            }
            
 			// edit general component of any elemental type
            $scope.getMergeInfo = function(param) {
            
                $scope.targetDetails = 'changed by'+ formatDetail(param.tgtChangedBy) + ' on'+formatDetail(param.tgtChangedOn);
                $scope.sourceDetails = 'changed by'+ formatDetail(param.changedBy) + ' on'+formatDetail(param.changedOn);

                if (param.compType == 'AuraDefinitionBundle' && !$scope.EditBundle){
                	$scope.openPopUpInfo(param);
                	return;
                }
                
                if (notEditableLi[param.compType]){
                	$scope.replace2.setX({selected: param.replace, alwaysDo: $scope.alwaysDo});
 	            	ModalService.showModal({
            			templateUrl: 'custom.html',
            			controller: 'CustomController',
            			preClose: (modal) => { modal.element.modal('hide'); }
    				}).then(function(modal) {
      					modal.element.modal();
      					modal.close.then(function(result) {
       						result = $scope.replace2.getX();
      						////console.log('choice from service:'+JSON.stringify(result));
        					if (result != undefined){
    	    					if (result.selected != 0 ){
    	    						param.isConflict = false;
                        			param.isManualMerge = true;
			                        param.compare = MERGED;
                        			param.replace = result.selected; // set flag to replace att by scheme: compAttId => repCompAttId
                        			$scope.alwaysDo = result.alwaysDo;
                        			if (result.alwaysDo){
                        				////console.log('do for all');
                        				setParameter($scope.componentListPtr,result.selected);
                        			}
        						}
        					}
      					});
    				});
	            	return;
	            }
                
                $scope.loading = false;
                
        	    if  (!ArchiveService.inStack(param.compId)){
            		$scope.loadComponent(param);
			        $scope.loading = true;
			        return;
				}
				
				if (param.compType != 'AuraDefinitionBundle'){				
               		var MergeInfo = ArchiveService.getZipDescription(param.compId);// get descriptor for edited component 
	               	var compId =  param.compId;   
               	}else{							//		use alternative stack if aura component
               		var MergeInfo = bundleComponentStack[param.uid];
	               	var compId =  param.uid;   
               	}
               	var component = param;

                 if (MergeInfo != undefined){
 					itemType = (MergeInfo.IsXML)?'XML':'TEXT';
                    $scope.PopUp = {}; // its an object to hold info about edited component
                    $scope.PopUp.title = param.compType + ' : ' + param.compName;
                    $scope.PopUp.compName = param.compName;
                    $scope.PopUp.compType = param.compType;

                    $scope.PopUp.base = MergeInfo.source;
                    $scope.PopUp.newfile = MergeInfo.target;

                    $scope.PopUp.EtalonValue = '';
                    $scope.PopUp.BackUp = MergeInfo.bkUp;
                    $scope.PopUp.ItemId = compId;

                    $scope.PopUp.ManualMerge = function(txt) {
                        ArchiveService.setMergeFile(compId, txt);
                        component.isConflict = false;
                        component.isManualMerge = true;
                        component.compare = MERGED;
                        if ($scope.EditBundle) param.conflictCode = 2; 
                        $scope.CommitStep = $scope.EditBundle?4:0;
                    }
                    $scope.PopUp.ManualMergeXml = function(xml,xmlBk,patch) {
                        ArchiveService.setMergeFile(compId, xml,patch);
                        //debug(JSON.stringify(MergeInfo));
                        ArchiveService.setBkUp(compId, xmlBk);
                        component.isConflict = false;
                        component.isManualMerge = true;
                        component.compare = MERGED;
                        if ($scope.EditBundle) param.conflictCode = 2; 
                        $scope.CommitStep = $scope.EditBundle?4:0;
                        $scope.dataProcessing = false;

                        delete param;
                    }
                    
                    $scope.PopUp.closeManualMerge = function() {
                        $scope.CommitStep = $scope.EditBundle?4:0;

                        delete param;
                        delete $scope.PopUp;
                    }
                    $scope.PopUp.closeManualMergeXml = function(xmlBk) {
                        $scope.CommitStep = $scope.EditBundle?4:0;
                        setBkUp(compId, xmlBk);
						$scope.dataProcessing = false;

                        delete param;
                        delete $scope.PopUp;
                        //debug('delete popup');
                    }
                    
                    if (MergeInfo.IsXML) {
                        $scope.CommitStep = 3;
                        $scope.isLoading = true;
                    }
                    else {
                        $scope.CommitStep = 2;
                        $scope.isLoading = true;
                    }
                    
                }
                clearMessage();
 				//debug('step:'+$scope.CommitStep);               
            };

 
            
          // verify are all conflicts for selected components resolved   
           $scope.getStatusConflicts = function() {
                for (var x = 0; x < $scope.componentList.length; x++) {
                	if ($scope.componentList[x].check){// verify only checked
                		if ($scope.componentList[x].isConflict){
                			return true;
                		}else if (CONSIDER_META && $scope.componentList[x].meta != undefined && $scope.componentList[x].meta.isConflict){
                			return true;
                		}
                	}
                }
                return false;
            }

            
            $scope.disableNextPreviousButton = function() {
                $scope.$apply(function() {
                       $scope.disableNextPrevious = true;
                });
            };
            
            $scope.enableNextPreviousButton = function() {
                $scope.$apply(function() {
                       $scope.disableNextPrevious = false;
                });
            };

            $scope.setDataProcessFlag = function() {
                $timeout(function() {
                       $scope.dataProcessing = true;
                });
            };
            
            $scope.clearDataProcessFlag = function() {
	              $timeout(function() {
                       $scope.dataProcessing = false;
                });
            };
			
			// Helper method to get selected items
  			$scope.selectedComps = function selectedComps() {
			    return filterFilter($scope.componentList, { selected: true });
  			};

			// Helper method to get selected items
  			$scope.selectedComps2 = function selectedComps2() {
			    return filterFilter($scope.newCompList, { selected: true });
  			};
  			
  			$scope.selectRelated = function(item,list){
  			  	var i = item.compType.indexOf('(meta)');
  				var filterValue = i == -1 ? (item.compType + '(meta)'):item.compType.slice(0,i);
  				//////console.log('filterValue:'+filterValue);
  				setAll(filterFilter(list, { compType: filterValue, compName: item.compName }),item.check);
  			}
  			
  			
  			  // Watch componentList for changes
  			$scope.$watch('componentList|filter:{check:true}', function (nv) {
			    $scope.selectionConflict = nv.map(function (c) {
      				return c.compId;
    			});
  			}, true);
            
  			  // Watch componentList for changes
  			$scope.$watch('newCompList|filter:{check:true}', function (nv) {
			    $scope.selectionNew = nv.map(function (c) {
      				return c.compId;
    			});
  			}, true);
            
            $scope.checkUncheck = function(compLi,nList) {
            	if (nList == 1){
                 	isAllChecked1 = $scope.isAllChecked1;
                 	setAll(compLi,isAllChecked1); 
                }else if (nList == 2){
                 	isAllChecked2 = $scope.isAllChecked2;
                 	setAll(compLi,isAllChecked2); 
            	}else{
            		isAllChecked1 = false; 
            		isAllChecked2 = false;
            		setAll(compLi,false);
            	}	
            };
            
            
            
            $scope.disableMergeButton = function(){
            	$timeout(function() {
            		$scope.mergeButton = true;
            	});
            }

            $scope.disableUI = function(flag){
            	$timeout(function() {
            		$scope.mergeButton = flag;
            		$scope.enableTables = false;
            		$scope.disableAllUI = flag;
            	});
            }

            $scope.enableMergeButton = function(){
            	$timeout(function() {
            		$scope.mergeButton = false;
            	});
            }
            
            function showMainBlock(){
            	getScope().setDataProcessFlag();
            }
            
            function setAll(array,isAllChecked){
            	for(var index = 0; index < array.length; index++) {
                    if(isAllChecked)
                        array[index].check = true;
                    else
                        array[index].check = false;  
                 }
            }
            
            function mergeArray(array,arrayToMerge){
            	
            	if (arrayToMerge.length > 0){
            		for (var i = 0; i < arrayToMerge.length; i++){
            			array.push(arrayToMerge[i]);
            		}
            	}
            }
            
            
          
        /************************			Init section				****************************/    
		// init the variables for controller

		$scope.initLoad = function(){ 
			$scope.updatePages();
			var err = {!errorCode};
		
			if (err === 0){
				if ($scope.brSelect != '' && $scope.brSelect != undefined){
					$scope.targetBranchName = 'Component from target branch '+ getBranchName($scope.brSelect,$scope.allBranches);
					setMessageOnPage('Loading Data...');
					$scope.isLoading = true;
					////////console.log('isLoading = true');
					$j('#spinner').css('display','initial');
				
					$scope.loadData($scope.brSelect, function(){
										////console.log('calling final');
										$scope.finalLoad();
										clearMessage();
									});
					CacheService.initCacheService();
				}else{// for empty branchid
						$j('#spinner').css('display','none');
						$scope.isLoading = false;
						$scope.enableTables = false;
				}
			}else if (err === 1 || err === 2){// merge in process
				$scope.disableMergeButton();
				$j('#spinner').css('display','none');
				$scope.isLoading = false;
				$scope.enableTables = false;
			}else {
				$scope.disableMergeButton();
				$j('#spinner').css('display','none');
				$scope.isLoading = false;
				$scope.enableTables = false;
			}
		}
		
		$scope.initLoad();
		
		function getBranchName(id,array){
			if (array != undefined && array.length > 0){
				for( var x = 0; x < array.length; x++){
					if (array[x].branchId === id) return array[x].branchName;
				}
			}
		}
		
		if ({!errorCode} === 0){
			$scope.allBranches = JSON.parse('{!JSENCODE(allBranchesStr)}');
			$scope.sourceBranchName = 'Component from source branch '+'{!JSENCODE(srcBranchName)}';
		}
		
		$scope.onChange = function(){
			if ($scope.brSelect === '' || $scope.brSelect == undefined){
				CacheService.initCacheService();
				$timeout(function(){
					$scope.onlyExistingBranches = false;
					$scope.enableTables = false;
				});
			}else{
				$scope.onlyExistingBranches = true;
				$scope.initLoad();
			}
		}
		
         /* code for the new comparison panel */
        
			
           var windowSize = getWidth();

            
            $scope.isLoading = false;

            $scope.STYLE_UPDATED = {"background-color":COLOR_CHANGED};

			$scope.editor = {};
            $scope.editor.viewCollection = []; // pointers to elems of rowCollection
            $scope.editor.counter = 0;
            var counter = 0;
            var guidCounter = 0;
            
            $scope.editor.copyAllFlag = false;
            $scope.editor.changesOnly = true;
            $scope.editor.ignoreWS = true;
            $scope.editor.isEquivalent = false; // set initial value to true, if obj are different, this value will be reseted
            $scope.isEqual = false;
            $scope.isXmlValid = true;
            
            $scope.diffXML;
            $scope.file;

            var isEqual;
            var editedInAce = false;
            var editor;

			$scope.initxmlpanel = function (){
					if (CacheService.isCached($scope.PopUp.ItemId)){
						CacheService.pop($scope.PopUp.ItemId, function(data){
							editor = new Editor($scope.editor, true, $scope.PopUp.compType);
							editor.setVarsFromPack(data,$scope);
		        		    $scope.isLoading = false;
						});
					}else{
						editor = new Editor($scope.editor, true, $scope.PopUp.compType);
		                setWindowParams(true);
						$scope.diffXml();
					}
        	    $scope.isLoading = false;
        	    $scope.isEqual = editor.viewCollection.length == 0;
            }


			$scope.diffXml = function (){
				//console.log('call diffXml');
				$scope.isXmlValid = true;
				var src = $scope.PopUp.base;
				var tgt = $scope.PopUp.newfile;
			
				editor.superTag = getView($scope.PopUp.compType, src, tgt);
				if (editor.superTag == undefined){
					$scope.isXmlValid = false;
					return;
				}
				editor.isEqual = true;
				editor.fileType = XML;
           		editor.linearize($scope.diffXML,'',0,0);
            	editor.updateList(!$scope.editor.changesOnly);
            	editor.correctXmlMargines();
   	        	$scope.editor.isEquivalent = editor.isEqual;
			
			}
			
			$scope.inittxtpanel = function (){
					if (CacheService.isCached($scope.PopUp.ItemId)){
						CacheService.pop($scope.PopUp.ItemId, function(data){
							editor = new Editor($scope.editor, false);
							editor.setVarsFromPack(data,$scope);
		        		    $scope.isLoading = false;
						});
					}else{
 						editor = new Editor($scope.editor, false);
            		    setWindowParams(false);
						$scope.diffTxt();
					}
        	    $scope.isLoading = false;
        	    $scope.isEqual = editor.viewCollection.length == 0;
			}
			
			$scope.diffTxt = function (){
					var src = $scope.PopUp.base;
					var tgt = $scope.PopUp.newfile;

					var diff3;

					var d1 = new Mgly.diff(src, tgt, {ignorews:$scope.editor.ignoreWS});
					if (d1 != undefined){
						diff3 = d1.get_difference_array();
					}
					
					editor.fileType = NONXML;
	                editor.linearizeText(diff3);
					editor.calculateTopMedian(diff3);
					editor.updateList(!$scope.editor.changesOnly);
			}

            $scope.changeView = function(algorithm){
            	 if (algorithm == '2'){
            	  	editor.resetVars(true);
            		editor.resetArrays(true);
            	 	$scope.diffTxt();
            	 }else{
                 	editor.updateList(!$scope.editor.changesOnly);
                 }

                 if (editor.fileType === XML){// for xml only
                 	editor.correctXmlMargines();
                 }
                 $scope.isEqual = $scope.editor.viewCollection.length == 0;
            }
           
            
            const DEFAULT_HEIGHT = 592;
            const MIN_HEIGHT = 150;
            const LINE_HEIGHT = 22;
            const FULL_NAME = 'fullName';
            const TAGS_ALWAYS_SHOWN = new Object();
            TAGS_ALWAYS_SHOWN[FULL_NAME] = true;
            
            function setEditorHeight(){
            	var nLines = editor.viewCollection.length;
            	var height = MIN_HEIGHT;
            	////console.log('number of lines:'+nLines);
            	if (nLines*LINE_HEIGHT > DEFAULT_HEIGHT) return;
            	if (nLines*LINE_HEIGHT > MIN_HEIGHT){
            		height = Math.floor(nLines*LINE_HEIGHT) + 1;
            	}
            	if (fileType === XML){
            		$j('#vertical-container-xml').css('height',height);
            	}else{
            		$j('#vertical-container-txt').css('height',height);
            	}
            }

           
            $scope.copyAll = function(directCopy) {
                editor.updateAll(directCopy);
            }
            
            
          function setWindowParams(xml){
                var maxCalcWindowSize = 16*editor.maxLineSize;
                windowSize = getWidth();
                var fontSize = window.getComputedStyle(document.body).getPropertyValue('font-size');
				var len = getCalcWidth(xml);  
				editor.SYM_W = len/10;
                editor.VALUE_SIZE = windowSize/(2*editor.SYM_W) - 37;
                //console.log(' editor.VALUE_SIZE='+ editor.VALUE_SIZE);

                $j('.headerTitle').css('width',windowSize/3);
                $j('.header').css('width',windowSize);
                $j('.headerButtonPlaceholder').css('width',windowSize/3);
                $j('.headerButton').css('width',windowSize/3);
                

				if (xml){
                	$j('#vertical-container-xml').css('width',windowSize);
                	$j('#xmlEditPanel').css('width',getWidth() + 50);
                }else{
               		$j('#vertical-container-txt').css('width',windowSize);
               		$j('#txtEditPanel').css('width',getWidth() + 50);
                }
            }
            
            $scope.updated = function (id) {
                editor.updateRow(id - 1);
            }

            $scope.updateBundle = function (item) {
				item.moved = !item.moved;
            }
            
            var aceEditor;
            var fileType;
            $scope.edit = function (type, mode) {
                fileType = type;
                var objToEdit;
                if (mode){
                	objToEdit = $scope.PopUp.base;
                }else{
	            	if (type == 0){
		                editor.initVars();
	    	            var json = editor.buildObj();
	        	        var x2js = new X2JS({useDoubleQuotes : true, stripWhitespaces : false, escapeMode: false});// X2JS({useDoubleQuotes : true, stripWhitespaces : false, escapeMode: false})
	                
    	        		var xml = x2js.json2xml_str(json);
						// xml = null - sign of error in xml structure, show warning
	                	if (xml == undefined){
    		            	xml = '<' + editor.mainTag + ' xmlns="http://soap.sforce.com/2006/04/metadata"/>\n'
    		            }
            		    objToEdit = xml;
                	}else if (type == 1){
                		objToEdit = editor.buildText();  
                	}
                }
				var editorPageUrl = '{!editMetaDataPageName}';
				var link = editorPageUrl + '?fileType=' + type + '&mode=' + mode;
				var obj = {};
				obj.type = type;
				obj.data = type == 0 ? formatXml(objToEdit) : objToEdit;//vkbeautify.xml
				obj.base = type == 0 ? formatXml($scope.PopUp.base) : $scope.PopUp.base;//vkbeautify.xml
				obj.mode = mode;
				obj.data = pako.deflate(obj.data, { to: 'string' });
				obj.base = pako.deflate(obj.base, { to: 'string' });
                $j("body").data( "userData", obj);
                var threadName = mode ? 'RO':'RW';
                var windowTitle = $scope.PopUp.compType + ' ' + $scope.PopUp.compName;
                var w = window.open(link, threadName, 'width=800,height=700,resizable=1,scrollbars=1');
                setTitle(w,windowTitle);
            }
            
            
            function setTitle(w, title){
	            w.onload = function(){
				    setTimeout(function(){
   						w.document.getElementsByTagName('head')[0].appendChild(document.createElement('title')).appendChild(document.createTextNode(title));
    				}, 5);
				}
			}
            
            $scope.applyChangesManual = function (updated) {
            	editor.resetVars(true);
            	editor.resetArrays(true);
            	if (updated != undefined){
 		           	$scope.PopUp.newfile = pako.inflate(updated.data, { to: 'string' });
					if (updated.type === 0){            	
            			$scope.diffXml();
            		}else if (updated.type === 1){
            			$scope.diffTxt();
            		}
            	}
            	editedInAce = true;
            	$timeout(function() {
                       $scope.editor.viewCollection = editor.viewCollection;
                });
            	
            	$scope.CommitStep = fileType == 0? 3: 2;
            }
            

            $scope.cancel = function () {
            	// empty all arrays, clear reset vars
            	editor.resetVars();
            	$scope.PopUp.closeManualMerge();
            }

            $scope.applyChangesXml = function () {
               editor.initVars();
                var json = editor.buildObj();
                var x2js = new X2JS({useDoubleQuotes : true, stripWhitespaces : false, escapeMode: false});
                
   	        	var xml = x2js.json2xml_str(json);
				// xml = null - sign of error in xml structure, show warning
               	if (xml == undefined){
   	            	xml = '<' + editor.mainTag + ' xmlns="http://soap.sforce.com/2006/04/metadata"/>\n'
   	            }
				xml = vkbeautify.xmlmin(xml,true);
                $scope.PopUp.ManualMergeXml(xml);
                CacheService.push($scope.PopUp.ItemId, editor.getVarsAsPack($scope));
                editor.resetVars();
            }
            
            $scope.applyChangesTxt = function () {
                var text = editor.buildText();  

                $scope.PopUp.ManualMerge(text);
                CacheService.push($scope.PopUp.ItemId, editor.getVarsAsPack($scope));
                editor.resetVars();
            }
            

            
            
            function getView(compType, sourcexml, targetxml) {
                   		var timer = function(name) {
						    var start = new Date();
							    return {
       								stop: function() {
            							var end  = new Date();
       	    							var time = end.getTime() - start.getTime();
       								}
   		   						}
						};
			         	if (ESCAPE_MODE){	
	                      sourcexml = escapeHTMLEntities(sourcexml);	
    	                  targetxml = escapeHTMLEntities(targetxml);
						}			  
  
                        var x2js = new X2JS({useDoubleQuotes : true, stripWhitespaces : false, escapeMode: false});

                        var sourceObj;
                        var targetObj;
                        
                        
                        sourceObj = x2js.xml_str2json( sourcexml );
                        targetObj = x2js.xml_str2json( targetxml );
                        if (targetObj == undefined || targetObj == null){// error in xml
                        	return;
                        }
                        $scope.file = targetxml;
                        
						var t =  timer('difference');
						var key = deepDiffMapper.getSuperKey(sourceObj);
						deepDiffMapper.setType(compType);
						diff3 = deepDiffMapper.map('MasterKey',sourceObj, targetObj);
						t.stop();
                        $scope.diffXML = diff3;
                        return key;
             }
             
           	var code = '{!errorCode}';
	
		
			if (code !== '0'){
				$scope.disableUI(true);
				$j('#spinner').css('display','none');
        		$scope.loading = false;
        		$scope.isLoading = false;
        		$scope.enableTables = false;
			}
             
                    

        });


    myApp.directive('postrenderAction', postrenderAction); 

	/* @ngInject */
	function postrenderAction($timeout) {
    // Directive Interface
    // Defines base properties for the directive.
    	var directive = {
        	restrict: 'A',
        	priority: 101,
    	    link: link
	    };
    	return directive;

    // Link Function
    // Provides functionality for the directive during the DOM building/data binding stage.
    	function link(scope, element, attrs) {
        	$timeout(function() {
            	scope.$evalAsync(attrs.postrenderAction);
	        }, 0);
    	}
	} 
    
	String.prototype.isXml = function () {
		return this.substr(0, 10).indexOf('<?xml') > -1 ? true : false;
	}

    function getWidth() {
        var width = $j(window).innerWidth() - 100;
        //debug('w='+width);
        return width;
    }
        
    var maxWidth =  getWidth();
        
    $j(window).on("resize",function() {
        maxWidth =  getWidth();

    });
    
        myApp.factory('ArchiveService', function($q) {
		var componentStack = {};	 // detail info about merged component
		var zipMap = {};	// map attId=>attachment
     	var counter = 0; // number of saved attachments
     	
     	function extractFile(zip1,zip2,comp){
			

			if (zip1.Id == comp.compAttId){
				var tempSrcZip = new JSZip(zip2.base64, {base64:true});
				var tempTgtZip = new JSZip(zip1.base64, {base64:true});
				if (zipMap[comp.compAttId] == undefined){
					zipMap[comp.compAttId] = zip1.base64;
				}
			}else{
				var tempSrcZip = new JSZip(zip1.base64, {base64:true});
				var tempTgtZip = new JSZip(zip2.base64, {base64:true});
				if (zipMap[comp.compAttId] == undefined){
					zipMap[comp.compAttId] = zip2.base64;// contains archive with [last version of] file
				}
			}
			if (comp.compType != 'AuraDefinitionBundle'){
				var descriptor = {};
				descriptor.compAttId = comp.compAttId; // set Attachment's ID which later will be used for update 
				descriptor.compType = comp.compType;
				descriptor.compName = comp.compName;
				descriptor.fileName = comp.fileName;
				descriptor.length = zipMap[comp.compAttId].length;
				descriptor.crc32 = comp.crc32;
				descriptor.source = tempSrcZip.file(comp.fileName).asText();
				descriptor.target = tempTgtZip.file(comp.fileName).asText();
				descriptor.IsXML = false;
				if (descriptor.target != undefined && descriptor.target != ''){
					descriptor.IsXML = descriptor.target.isXml();
				}
				return descriptor;// for non-aura return descriptor
			}else{//return array of descriptors for each file in AuraDefinitionBundle
				var srcDescrMap = {};
				for (var fileName in tempSrcZip.files){
					var descriptor = {};
					descriptor.compAttId = comp.compAttId; // set Attachment's ID which later will be used for update 
					descriptor.compType = comp.compType;
					descriptor.compName = fileName.substr(fileName.lastIndexOf('/')+1);
					descriptor.fileName = fileName;
					descriptor.length = zipMap[comp.compAttId].length;
					descriptor.source = tempSrcZip.file(fileName).asText();
					if (descriptor.source != null && descriptor.source != ''){
						descriptor.IsXML = descriptor.compName.indexOf('-meta.xml') == -1 ? false : true;// set xml flag only for meta
						descriptor.crc32 = tempSrcZip.crc32(descriptor.source,32);
						srcDescrMap[descriptor.compName] = descriptor;//return not-null only if source != null
					}
				}
				var tgtDescrMap = {};
				for (var fileName in tempTgtZip.files){
					var descriptor = {};
					descriptor.compAttId = comp.compAttId; // set Attachment's ID which later will be used for update 
					descriptor.compType = comp.compType;
					descriptor.compName = fileName.substr(fileName.lastIndexOf('/')+1);
					descriptor.fileName = fileName;
					descriptor.length = zipMap[comp.compAttId].length;
					descriptor.target = tempTgtZip.file(fileName).asText();
					if (descriptor.target != null && descriptor.target != ''){
						descriptor.IsXML = descriptor.compName.indexOf('-meta.xml') == -1 ? false : true;// set xml flag only for meta
						descriptor.crc32 = tempTgtZip.crc32(descriptor.target,32);
						tgtDescrMap[descriptor.compName] = descriptor;//return not-null only if target != null
					}
				}
				var lst = [];
				lst.push(srcDescrMap);
				lst.push(tgtDescrMap);
				return lst;
			}
		}
		
		// save merged file back to zip, updates crc32
		function setMergeFile(ItemId, File, patch){// patch var - depricated
			 //debug('ItemId='+ItemId);
			 if (ItemId.length > 4){	
  			 	var Item = componentStack[ItemId];// long id - general component, short - bundle; short id always temporal (valid only during edition)
  			 }else{
  			 	var Item = bundleComponentStack[ItemId];
  			 	Item.conflictCode = 2;// set flag indicated that new merge File in Bundle has been updated at least once
  			 }
  			 
			 if (File != undefined && File != '' && Item != undefined){
	             if (Item.IsXML) {
 					var resultXML = File;
	                if (resultXML.isXml()) {
   	               		Item.mergeFile = resultXML;
   	               	}else{
        	        	resultXML = vkbeautify.xmlmin(resultXML, true);
            	       	Item.mergeFile = '<?xml version="1.0" encoding="UTF-8"?>' + formatXml(resultXML);
                	}
    	         }
        	     else {
                    Item.mergeFile = File;
            	 }
             }else if (Item != undefined){
				Item.mergeFile = File;
             }else{
             	// nothing todo
             	return;
             }
             // update archive
             var isBinary = false;
             var archive = zipMap[Item.compAttId];// for bundle case - updates contents of bundle zip
             if (archive != undefined){
	                 var tempZip = new JSZip(archive, {base64:true});
	                 if (Item.mergeFile != '' && Item.mergeFile != undefined){//empty file means delete operation
    		             tempZip.file(Item.fileName,Item.mergeFile,{binary:isBinary});// if component with fileName does not exist, create it
	            	     updateCRC32(Item, tempZip.crc32(Item.mergeFile,32));
	                 }else{
	                 	 //////console.log('delete file:'+Item.fileName);
    		             tempZip.remove(Item.fileName);
	            	     Item.crc32 = '';
	                 }
   	    	         zipMap[Item.compAttId] = tempZip.generate({type:"base64",compression:"DEFLATE"});
             }
             //debug('updated,new crc='+Item.crc32);
            Item.isManualMerge = true; // set flag indicated that new merge File has been created at least once
             
		}
		
		function setBkUp(Id, xmlBk){
			 if (Id.length > 4){	
				var descriptor = componentStack[Id];
  			 }else{
  			 	var descriptor = bundleComponentStack[Id];
  			 }
  			 if (descriptor != undefined){
            	descriptor.bkUp = xmlBk;
             }else{
             	////console.log('error: descriptor is null');
             }
		}
		
			
     	
     	
     	return {
                addZips: function(zip1,zip2,comp) {// adds the zip; if exists, update with a new data
                	if (componentStack[comp.compId] != undefined){
                		counter++;
                	}
                	componentStack[comp.compId] = extractFile(zip1,zip2,comp);;
                },
                updateTargetZip: function(compId, data) {//  update with a new data
                	if (componentStack[compId] != undefined){
	                	componentStack[compId][1] = data;
                	}
                },
                setMergeFile: function(ItemId, File, patch){
                	setMergeFile(ItemId, File, patch);
                },
                setBkUp: function(Id, xmlBk){
                	setBkUp(Id, xmlBk);
                },
                getZipDescription: function(compId){
                	return componentStack[compId];
                },
                getZip: function(attId){
                	return zipMap[attId];
                },
                setZip: function(attId, data){
                	zipMap[attId] = data;
                },
                getLength: function(attId){
                	if (zipMap[attId] != undefined){
                		return zipMap[attId].length;
                	}else{
                		return 0;
                	}
                },
                initArchiveService: function() {
                      componentStack = {};
                      zipMap = {};
                      counter = 0;
                },
                inStack: function(compId){
                    return componentStack[compId] != undefined;
                }
    
        };
     		
    });
    
    
     myApp.factory('CacheService', function($q) {
     	var archive = {};// map compId => compressed data
     	var counter = 0;
     	var callFunct;
     	
     	function _getData(compId,callback){
     		callFunct = callback; // set function to return data
     		var returnObj = {};
     		if (archive[compId] != undefined){
     			returnObj = JSON.parse(pako.inflate(archive[compId], { to: 'string' }));
     		}
     		callFunct(returnObj);
     	}
     	
     	return {
                pop: function(compId, callback) {
                    _getData(compId,  function(data){
                            callback(data);
                     });
                },
                push: function(compId, data) {
                	  var compressedData =  JSON.stringify(data);
                	  if (archive[compId] == undefined){
                	  	counter++;
                	  }
                      archive[compId] =  pako.deflate(compressedData, { to: 'string' }); 
                },
                initCacheService: function() {
                      archive = {};
                      counter = 0;
                },
                isCached: function(compId){
                    return archive[compId] != undefined;
                }
    
        };
     
     });
        
    // restore all original view of special symboles in xml file - adopted for SF     
    function unescape1XmlChars(str) {
		return str.replace(/&#x27;/g, "'");
	}
        
		
	// wrapper for debug, works if flag DEBUG_MODE == true 
	function debug(msg){
		if (DEBUG_MODE){
			////console.log(msg);
		}
	}
    
    // global function called after branch is changed 
    function onChange(){
        	//console.log('branch changed!');
    }
               
    function callBackText(editedObj){
            	getScope().applyChangesManual(editedObj);
    }
       
    function isEmpty(val){
    	return val == undefined || val == null || val == '';
    }
    
    function getScope(){
    	return angular.element(document.getElementById('angularControllerId')).scope();
    }
            
  
   </script>

</apex:page>